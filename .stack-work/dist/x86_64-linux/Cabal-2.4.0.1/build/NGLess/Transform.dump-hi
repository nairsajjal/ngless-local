
==================== FINAL INTERFACE ====================
2020-02-24 04:15:27.076532893 UTC

interface NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5:Transform 8065
  interface hash: 5bdce2306df45a319127854991fc17bf
  ABI hash: b78ecedc7dc4ecf65d548a878f537150
  export-list hash: e591b5b6dd1c9f48dc19bd6bf02c0e6f
  orphan hash: 361a85c94cf9ccb523dd1b43820b3246
  flag hash: af0c445c587eaa59b2143ec7cebee05f
  opt_hash: 9851e58a0ec35d0fd39c07cdbeb6257b
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Transform.isVarUsed
  Transform.isVarUsed1
  Transform.pureTransform
  Transform.transform
module dependencies: BuiltinFunctions CmdArgs Configuration
                     Data.FastQ Data.Sam Dependencies.Embedded FileManagement
                     FileOrStream Language Modules NGLess NGLess.NGError
                     NGLess.NGLEnvironment Output Paths_NGLess Utils.Conduit
                     Utils.FindModules Utils.LockFile Utils.Samtools Utils.Suggestion
                     Utils.Utils Utils.Vector Version
package dependencies: JuicyPixels-3.3.4 MissingH-1.4.1.0
                      StateVar-1.2 active-0.2.0.14 adjunctions-4.4 aeson-1.4.6.0
                      ansi-terminal-0.9.1 ansi-wl-pprint-0.6.9 array-0.5.3.0 async-2.2.2
                      attoparsec-0.13.2.3 base-4.12.0.0 base-compat-0.10.5
                      base-orphans-0.8.1 base64-bytestring-1.0.0.2 bifunctors-5.5.6
                      binary-0.8.6.0 blaze-builder-0.4.1.0 bytes-0.15.5
                      bytestring-0.10.8.2 bzlib-conduit-0.3.0.2 call-stack-0.1.0
                      cereal-0.5.8.1 cereal-conduit-0.8.0 charset-0.3.7.1 colour-2.3.5
                      comonad-5.0.6 conduit-1.3.1.2 conduit-algorithms-0.0.11.0
                      conduit-extra-1.3.4 conduit-zstd-0.0.1.1 configurator-0.3.0.0
                      containers-0.6.0.1 contravariant-1.5.2 convertible-1.1.1.0
                      data-default-0.7.1.1 data-default-class-0.1.2.0
                      data-default-instances-containers-0.0.1
                      data-default-instances-dlist-0.0.1
                      data-default-instances-old-locale-0.0.1 deepseq-1.4.4.0
                      diagrams-core-1.4.2 diagrams-lib-1.4.3 diagrams-solve-0.1.1
                      diagrams-svg-1.4.3 directory-1.3.3.0 distributive-0.6.1
                      dlist-0.8.0.7 dual-tree-0.2.2.1 edit-distance-0.2.2.1 errors-2.3.0
                      exceptions-0.10.4 extra-1.6.18 file-embed-0.0.11.1 filepath-1.4.2.1
                      fingertree-0.1.4.2 free-5.1.3 ghc-boot-th-8.6.5 ghc-prim-0.5.3
                      gitrev-1.3.1 hashable-1.2.7.0 hostname-1.0 inline-c-0.7.0.1
                      integer-gmp-1.0.2.0 integer-logarithms-1.0.3 intervals-0.8.1
                      kan-extensions-5.2 lens-4.17.1 linear-1.20.9 lzma-0.0.0.3
                      lzma-conduit-1.2.1 monad-loops-0.4.3 mono-traversable-1.0.15.1
                      monoid-extras-0.5.1 mtl-2.2.2 newtype-generics-0.5.4
                      old-locale-1.0.0.7 old-time-1.1.0.3 optparse-applicative-0.14.3.0
                      parsec-3.1.14.0 parsers-0.12.10 pretty-1.1.3.6 primitive-0.6.4.0
                      process-1.6.5.0 profunctors-5.3 random-1.1 reflection-2.1.5
                      regex-1.0.2.0 regex-base-0.93.2 regex-compat-0.95.1
                      regex-pcre-builtin-0.94.5.8.8.35 regex-posix-0.95.2
                      regex-tdfa-1.2.3.2 regex-tdfa-text-1.0.0.3 resourcet-1.2.2
                      safe-0.3.18 safeio-0.0.5.0 scientific-0.3.6.2 semigroupoids-5.3.4
                      split-0.2.3.3 stm-2.5.0.0 stm-chans-3.0.0.4 stm-conduit-4.0.1
                      streaming-commons-0.2.1.1 strict-0.3.2 svg-builder-0.1.1
                      tagged-0.8.6 tar-0.5.1.1 template-haskell-2.14.0.0 text-1.2.3.1
                      th-abstraction-0.3.1.0 time-1.8.0.2 time-compat-1.9.2.2
                      time-locale-compat-0.1.1.5 transformers-0.5.6.2
                      transformers-base-0.4.5.2 transformers-compat-0.6.5 unix-2.7.2.2
                      unix-compat-0.5.2 unliftio-0.2.12 unliftio-core-0.1.2.0
                      unordered-containers-0.2.10.0 utf8-string-1.0.1.1 uuid-types-1.0.3
                      vector-0.12.0.3 vector-algorithms-0.8.0.3 zlib-0.6.2.1 zstd-0.1.1.2
orphans: data-default-instances-containers-0.0.1:Data.Default.Instances.Containers
         data-default-instances-dlist-0.0.1:Data.Default.Instances.DList
         data-default-instances-old-locale-0.0.1:Data.Default.Instances.OldLocale
         conduit-extra-1.3.4:Data.Conduit.Process
         regex-1.0.2.0:Text.RE.TDFA.String
         regex-tdfa-text-1.0.0.3:Text.Regex.TDFA.Text
         regex-tdfa-text-1.0.0.3:Text.Regex.TDFA.Text.Lazy
         regex-pcre-builtin-0.94.5.8.8.35:Text.Regex.PCRE.String
         regex-pcre-builtin-0.94.5.8.8.35:Text.Regex.PCRE.Sequence
         regex-pcre-builtin-0.94.5.8.8.35:Text.Regex.PCRE.ByteString.Lazy
         regex-pcre-builtin-0.94.5.8.8.35:Text.Regex.PCRE.ByteString
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.ByteString
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.ByteString.Lazy
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.Sequence
         regex-tdfa-1.2.3.2:Text.Regex.TDFA.String
         regex-posix-0.95.2:Text.Regex.Posix.String
         regex-posix-0.95.2:Text.Regex.Posix.Sequence
         regex-posix-0.95.2:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2:Text.Regex.Posix.ByteString
         regex-base-0.93.2:Text.Regex.Base.Context
         convertible-1.1.1.0:Data.Convertible.Instances.C
         convertible-1.1.1.0:Data.Convertible.Instances.Map
         convertible-1.1.1.0:Data.Convertible.Instances.Text
         convertible-1.1.1.0:Data.Convertible.Instances.Time
         convertible-1.1.1.0:Data.Convertible.Instances.Num
         attoparsec-0.13.2.3:Data.Attoparsec.ByteString.Char8
         diagrams-lib-1.4.3:Diagrams.Animation.Active
         diagrams-lib-1.4.3:Diagrams.TwoD.Path
         diagrams-lib-1.4.3:Diagrams.TwoD.Segment
         diagrams-lib-1.4.3:Diagrams.Trail
         diagrams-lib-1.4.3:Diagrams.ThreeD.Types
         diagrams-lib-1.4.3:Diagrams.TwoD.Types
         diagrams-core-1.4.2:Diagrams.Core.Types
         monoid-extras-0.5.1:Data.Monoid.MList
         diagrams-core-1.4.2:Diagrams.Core.Points
         time-1.8.0.2:Data.Time.Clock.TAI reflection-2.1.5:Data.Reflection
         linear-1.20.9:Linear.Instances vector-0.12.0.3:Data.Vector.Unboxed
         vector-0.12.0.3:Data.Vector.Fusion.Bundle
         configurator-0.3.0.0:Data.Configurator.Instances
         attoparsec-0.13.2.3:Data.Attoparsec.Text.Internal
         colour-2.3.5:Data.Colour hashable-1.2.7.0:Data.Hashable.Generic
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.6.2:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: JuicyPixels-3.3.4:Codec.Picture.Tga
                         JuicyPixels-3.3.4:Codec.Picture.Tiff
                         JuicyPixels-3.3.4:Codec.Picture.Types
                         NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5:NGLess.NGError
                         active-0.2.0.14:Data.Active adjunctions-4.4:Data.Functor.Rep
                         aeson-1.4.6.0:Data.Aeson.Types.Internal
                         attoparsec-0.13.2.3:Data.Attoparsec.Internal.Types
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         bifunctors-5.5.6:Data.Bifunctor.Biff
                         bifunctors-5.5.6:Data.Bifunctor.Clown
                         bifunctors-5.5.6:Data.Bifunctor.Fix
                         bifunctors-5.5.6:Data.Bifunctor.Flip
                         bifunctors-5.5.6:Data.Bifunctor.Join
                         bifunctors-5.5.6:Data.Bifunctor.Joker
                         bifunctors-5.5.6:Data.Bifunctor.Product
                         bifunctors-5.5.6:Data.Bifunctor.Sum
                         bifunctors-5.5.6:Data.Bifunctor.Tannen
                         bifunctors-5.5.6:Data.Bifunctor.Wrapped bytes-0.15.5:Data.Bytes.Get
                         bytes-0.15.5:Data.Bytes.Signed bytes-0.15.5:Data.Bytes.VarInt
                         conduit-1.3.1.2:Data.Conduit.Internal.Conduit
                         conduit-1.3.1.2:Data.Conduit.Internal.Pipe
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         diagrams-core-1.4.2:Diagrams.Core.Envelope
                         diagrams-core-1.4.2:Diagrams.Core.Measure
                         diagrams-core-1.4.2:Diagrams.Core.Names
                         diagrams-core-1.4.2:Diagrams.Core.Points
                         diagrams-core-1.4.2:Diagrams.Core.Query
                         diagrams-core-1.4.2:Diagrams.Core.Style
                         diagrams-core-1.4.2:Diagrams.Core.Trace
                         diagrams-core-1.4.2:Diagrams.Core.Transform
                         diagrams-core-1.4.2:Diagrams.Core.Types
                         diagrams-core-1.4.2:Diagrams.Core.V
                         diagrams-lib-1.4.3:Diagrams.Angle
                         diagrams-lib-1.4.3:Diagrams.Animation.Active
                         diagrams-lib-1.4.3:Diagrams.BoundingBox
                         diagrams-lib-1.4.3:Diagrams.Coordinates
                         diagrams-lib-1.4.3:Diagrams.Direction
                         diagrams-lib-1.4.3:Diagrams.Located
                         diagrams-lib-1.4.3:Diagrams.Path
                         diagrams-lib-1.4.3:Diagrams.Segment
                         diagrams-lib-1.4.3:Diagrams.Size
                         diagrams-lib-1.4.3:Diagrams.Tangent
                         diagrams-lib-1.4.3:Diagrams.ThreeD.Camera
                         diagrams-lib-1.4.3:Diagrams.ThreeD.Light
                         diagrams-lib-1.4.3:Diagrams.ThreeD.Shapes
                         diagrams-lib-1.4.3:Diagrams.ThreeD.Types
                         diagrams-lib-1.4.3:Diagrams.Trail
                         diagrams-lib-1.4.3:Diagrams.TwoD.Attributes
                         diagrams-lib-1.4.3:Diagrams.TwoD.Image
                         diagrams-lib-1.4.3:Diagrams.TwoD.Path
                         diagrams-lib-1.4.3:Diagrams.TwoD.Segment.Bernstein
                         diagrams-lib-1.4.3:Diagrams.TwoD.Text
                         diagrams-lib-1.4.3:Diagrams.TwoD.Types
                         diagrams-svg-1.4.3:Diagrams.Backend.SVG dlist-0.8.0.7:Data.DList
                         dual-tree-0.2.2.1:Data.Tree.DUAL.Internal
                         fingertree-0.1.4.2:Data.FingerTree
                         free-5.1.3:Control.Comonad.Cofree
                         free-5.1.3:Control.Comonad.Trans.Cofree
                         free-5.1.3:Control.Monad.Free free-5.1.3:Control.Monad.Trans.Free
                         ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         inline-c-0.7.0.1:Language.C.Inline
                         inline-c-0.7.0.1:Language.C.Inline.Context
                         intervals-0.8.1:Numeric.Interval.Kaucher
                         kan-extensions-5.2:Data.Functor.Day
                         kan-extensions-5.2:Data.Functor.Yoneda lens-4.17.1:Control.Lens.At
                         lens-4.17.1:Control.Lens.Internal.Indexed
                         lens-4.17.1:Control.Lens.Reified lens-4.17.1:Control.Lens.Tuple
                         lens-4.17.1:Control.Lens.Wrapped lens-4.17.1:Control.Lens.Zoom
                         linear-1.20.9:Linear.Affine linear-1.20.9:Linear.Plucker
                         linear-1.20.9:Linear.Quaternion linear-1.20.9:Linear.V
                         linear-1.20.9:Linear.V0 linear-1.20.9:Linear.V1
                         linear-1.20.9:Linear.V2 linear-1.20.9:Linear.V3
                         linear-1.20.9:Linear.V4
                         mono-traversable-1.0.15.1:Data.MonoTraversable
                         mono-traversable-1.0.15.1:Data.NonNull
                         mono-traversable-1.0.15.1:Data.Sequences
                         newtype-generics-0.5.4:Control.Newtype.Generics
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         profunctors-5.3:Data.Profunctor.Composition
                         profunctors-5.3:Data.Profunctor.Rep
                         regex-1.0.2.0:Text.RE.ZeInternals.NamedCaptures
                         resourcet-1.2.2:Control.Monad.Trans.Resource.Internal
                         stm-conduit-4.0.1:Data.Conduit.Async.Composition
                         tagged-0.8.6:Data.Tagged
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.3.1.0:Language.Haskell.TH.Datatype
                         unliftio-0.2.12:UnliftIO.Internals.Async
                         unordered-containers-0.2.10.0:Data.HashMap.Base
                         unordered-containers-0.2.10.0:Data.HashSet.Base
                         uuid-types-1.0.3:Data.UUID.Types.Internal
                         uuid-types-1.0.3:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.3:Data.Vector vector-0.12.0.3:Data.Vector.Primitive
                         vector-0.12.0.3:Data.Vector.Storable
                         vector-0.12.0.3:Data.Vector.Unboxed
                         vector-0.12.0.3:Data.Vector.Unboxed.Base
                         zlib-0.6.2.1:Codec.Compression.Zlib.Stream
import  -/  MissingH-1.4.1.0:Data.Hash.MD5 0d16de4f61eb14f1b7b0b3475b4d085b
import  -/  BuiltinFunctions c2568683b34fc338dfcf729a27429f2c
  exports: 4fabbbd5eb29dc18c7c546be1dc1f0af
  findFunction 6b2ebb5b13ac6d0b81860d0bf3a98228
import  -/  Language 93f0f50a5c7ee77231d71d6a98e7a8ca
  exports: 6aa5d24204c11e6b2a36767cd645b21f
  Assignment 4c0195db0fce84d2e9e704269e836114
  BOpGT 6c4ebb5e00c07ea1a168bdb25331e25d
  BOpGTE 66d8a5dbec68bc11f3d8ac356d4fd75e
  BOpLT efffe19041efe96e15c29e1b76d8babe
  BOpLTE 757abdb965c9346d42ce17c336a0c9aa
  BinaryOp 96aebef7d64d3dee5736581d4fd6e787
  Block b24cb7195615293a75c1fd31f7a228f2
  Block adc8def6a4b7257bb12aef607cf99238
  BuiltinConstant df58b1abf5535a0feb227c294c839942
  Condition 5ee65797fc128c25b56f8d9e376f1857
  ConstBool e8c69dda06d722ad76d6ee5b57016100
  ConstInt 8a960333f4a81e1ab77c58419b086b64
  ConstStr 1facc51f598e05827c5695d189d62844
  Discard f62cf359094cb85b59e3d728c5b82948
  Expression adc8def6a4b7257bb12aef607cf99238
  FuncName a3f44134039f1915698a791072d2c89e
  FunctionCall 23e51bd4b17fae101afcee641d2d9aa8
  IndexExpression 1b396d3ca8c8b8b8954b5ee9745fd162
  IndexOne f52ed1b667b98a95d0a7a81716ddc6ac
  LenThresholdDiscard fd3da8aa7b002fe2c64616e448888400
  Lookup 9af0655858caf9a44c41b1765edc7910
  MethodCall 009cfcd1ea42375ebf8583c67b0f9ceb
  MethodName 3a7b3929a7abcd9627c07af2ab496db6
  NGLVoid 270592e6e6b718e69ed7d1f1dcc78ccb
  Optimized f5901d6f38fa97c9d12fea16c9f226ff
  Script 0fc401e1e5fe34e2879ec0a07ef86944
  Script 76fe0974e0c66dd0b2f466e0c453166d
  Sequence 629f5460e2af1b50496e5ea307340818
  SubstrimReassign 043be440a5735a40f05ee2b71df3f294
  UOpLen 4e5294a23d580f449388441e0a81293a
  UnaryOp 7ddfad96d4b058dc5f939d4cf881cf4f
  Variable 9b44f8caef4ce199ec53dca15d83da61
  Variable 6ea856e2345fb0911676ec309bc5b12f
  modName d7f124fd1704f8a7309c0e06610b0f29
  nglBody 76fe0974e0c66dd0b2f466e0c453166d
  nglHeader 76fe0974e0c66dd0b2f466e0c453166d
  recursiveAnalyse 3f8f09a6c366f341f144c8eb21071fbc
  recursiveTransform 109ac597482d4ed93187c0ab8fe3ed37
  usedVariables 81557d76bcaecc0d43010b933784d263
import  -/  Modules d7b04bae20d952778746efecd6f653cd
  exports: e612fb66accb36645cea5fb0c9541754
  ArgCheck 2a8aaf26348fbad4d70cb05dd401609a
  ArgCheckFileReadable cd7fc1b3a1f58dc68dacf1989a228470
  ArgCheckFileWritable 9f90833a7a0a74b35c853db084f576ec
  Module 5ea81178a37f2cc1f71e0dfed7af0657
  argChecks ac86c28a801be7ef411fb2dc303275ef
  argName ac86c28a801be7ef411fb2dc303275ef
  funcArgChecks ea8a515503aace5f77e7178c87cb63b2
  funcKwArgs ea8a515503aace5f77e7178c87cb63b2
  funcRetType ea8a515503aace5f77e7178c87cb63b2
  loadedModules 838ee0cd9914b71703bcd77a428ab74f
  modInfo 5ea81178a37f2cc1f71e0dfed7af0657
  modTransform 5ea81178a37f2cc1f71e0dfed7af0657
import  -/  NGLess a5aa819ac1d32c5f90c4109da4ddd56b
  exports: c338d02d81e70b5020d9e8bfbcb7ea8c
import  -/  NGLess.NGError 9175c652eec68d1a195f3eb2d7471cb5
  NGLess 416e5726ee4c4987c25367d545064990
  NGLessIO f1fd902a0de985a61e8d9110730dfc21
  runNGLess a41ed825730df1edb93a7b2b931843fe
  throwShouldNotOccur 6b0f4fcf8b2bcdc53931daab853fb839
import  -/  NGLess.NGLEnvironment 4ab4e397a1ac25f8e152520a0a756399
  exports: 140b883e1db9882b0aa097954c9eea1d
  NGLVersion c4336e12104b9327e88a42025f58523f
  nglEnvironment 56dd9663bd034f7047cca99f322e3b64
  ngleVersion d80a43c5bae03fd7eefc640474197c79
import  -/  Output 65dbbbf5895e64168b49be3b8326af6d
  exports: a41ff3401bfa3e00d33ddbc94a1eeb35
  TraceOutput eda030b46a813215b38990f8f484bfe9
  WarningOutput bb4505448b44871ee533a71ef46281ca
  outputListLno' 1a98fdc3c349e65a0f427ea401025c97
import  -/  Utils.Utils 5a5b516d92cb4d06150e4c1e7f1bff1d
  exports: c13ae65e393f7bcdefbb619c4fc6a77b
  secondM c8186bbce386eb96c592af2149a83d9c
  uniq ba993310bf5265579655b8098370a058
import  -/  base-4.12.0.0:Control.Arrow cda881e865dd3141fb08ed18f2efcca7
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.Functor.Identity f8b68112573f77a401c3389544bc0f0d
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:Data.Traversable d2c09bff1e4f0c871306c3ff8aa4dc36
import  -/  base-4.12.0.0:Data.Tuple c719fc29608fe81c10bee9a1bf1e05ff
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  containers-0.6.0.1:Data.Map.Internal fbf8d1bed47de2b3b48e26c406ee4050
import  -/  containers-0.6.0.1:Data.Map.Strict cdbeca9dfcd61c917272d3c2b8a5e4c8
import  -/  containers-0.6.0.1:Data.Map.Strict.Internal b2139318e1c1e3d44818931d9d007d9f
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  mtl-2.2.2:Control.Monad.Except 5ca04d82f027e75c6a16c1ed916c1305
import  -/  mtl-2.2.2:Control.Monad.Identity e802522ee1a00db34dedef519823c0df
import  -/  mtl-2.2.2:Control.Monad.RWS e4325c7769eef92ca0f28bedee9060e6
import  -/  mtl-2.2.2:Control.Monad.State.Class 243c828469104fb94563be0ea268f418
import  -/  mtl-2.2.2:Control.Monad.State.Lazy 7d371b0031c45953f2f91cf2f08d9b31
import  -/  mtl-2.2.2:Control.Monad.Writer 0c4563f022a89163556ba5d1725d5a20
import  -/  mtl-2.2.2:Control.Monad.Writer.Class 76e939c416a9f4ee6f62151a218e0c6b
import  -/  text-1.2.3.1:Data.Text e31b81fb349ec0694c028af9d897c500
import  -/  text-1.2.3.1:Data.Text.Internal 537e168590e8068f673f691833f78483
import  -/  transformers-0.5.6.2:Control.Monad.Trans.Cont 35abf84da5e3fbcec31d883b22db3d8a
import  -/  transformers-0.5.6.2:Control.Monad.Trans.RWS.Lazy dcd645d598e52f06aa769d196ed6d11f
import  -/  transformers-0.5.6.2:Control.Monad.Trans.State.Lazy 0c22827dedcb94d04bf072c00f8e95c2
import  -/  transformers-0.5.6.2:Control.Monad.Trans.Writer.Lazy a4150667521de72cdb82acb8195072e0
2221d7f19cb2f77179c41ff358cc7da2
  $s$fApplicativeRWST ::
    GHC.Base.Applicative
      (Control.Monad.Trans.RWS.Lazy.RWST
         r [Language.Expression] s Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r @ s.
                  @ (Control.Monad.Trans.RWS.Lazy.RWST
                       r [Language.Expression] s Data.Functor.Identity.Identity)
                  (Transform.$s$fApplicativeRWST_$s$fFunctorRWST
                     @ r
                     @ [Language.Expression]
                     @ s)
                  (Transform.$s$fApplicativeRWST_$s$fApplicativeRWST_$cpure @ r @ s)
                  (Transform.$s$fApplicativeRWST_$s$fApplicativeRWST_$c<*> @ r @ s)
                  (Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST2
                     @ [Language.Expression]
                     @ Data.Functor.Identity.Identity
                     @ r
                     @ s
                     (GHC.Base.$fMonoid[] @ Language.Expression)
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                           r [Language.Expression] s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                           r [Language.Expression] s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                                 <r>_R
                                 <[Language.Expression]>_N
                                 <s>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <c>_N))
                  (Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST3
                     @ [Language.Expression]
                     @ Data.Functor.Identity.Identity
                     @ r
                     @ s
                     (GHC.Base.$fMonoid[] @ Language.Expression)
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.RWS.Lazy.RWST
                      r [Language.Expression] s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                           r [Language.Expression] s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                                 <r>_R
                                 <[Language.Expression]>_N
                                 <s>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <b>_N))
                  (\ @ a @ b ->
                   Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST2
                     @ [Language.Expression]
                     @ Data.Functor.Identity.Identity
                     @ r
                     @ s
                     (GHC.Base.$fMonoid[] @ Language.Expression)
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.RWS.Lazy.RWST
                      r [Language.Expression] s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                           r [Language.Expression] s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                                 <r>_R
                                 <[Language.Expression]>_N
                                 <s>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <a>_N)) -}
2bbe6093e2cc0bcc96ea81cef03e3cbe
  $s$fApplicativeRWST_$s$fApplicativeRWST_$c<*> ::
    Control.Monad.Trans.RWS.Lazy.RWST
      r [Language.Expression] s Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.RWS.Lazy.RWST
         r [Language.Expression] s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.RWS.Lazy.RWST
         r [Language.Expression] s Data.Functor.Identity.Identity b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U(1*C1(U),1*U,1*U)))><L,1*C1(C1(U(1*U,1*U,1*U)))><L,U><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.RWS.Lazy.RWST
                            r [Language.Expression] s Data.Functor.Identity.Identity (a -> b))
                   (ds1 :: Control.Monad.Trans.RWS.Lazy.RWST
                             r [Language.Expression] s Data.Functor.Identity.Identity a)
                   (r1 :: r)
                   (s1 :: s) ->
                 let {
                   ds2 :: Data.Functor.Identity.Identity
                            (a -> b, s, [Language.Expression])
                   = ds
                       `cast`
                     (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                          <r>_R
                          <[Language.Expression]>_N
                          <s>_N
                          <Data.Functor.Identity.Identity>_R
                          <a -> b>_N)
                       r1
                       s1
                 } in
                 let {
                   ds3 :: Data.Functor.Identity.Identity (a, s, [Language.Expression])
                   = ds1
                       `cast`
                     (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                          <r>_R
                          <[Language.Expression]>_N
                          <s>_N
                          <Data.Functor.Identity.Identity>_R
                          <a>_N)
                       r1
                       (case ds2
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <(a -> b, s, [Language.Expression])>_R) of wild { (,,) f s' w2 ->
                        s' })
                 } in
                 (case ds2
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a -> b, s, [Language.Expression])>_R) of wild { (,,) f s' w2 ->
                  f (case ds3
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s, [Language.Expression])>_R) of wild1 { (,,) x s'' w' ->
                     x }) },
                  case ds3
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a, s, [Language.Expression])>_R) of wild { (,,) x s'' w' ->
                  s'' },
                  GHC.Base.augment
                    @ Language.Expression
                    (\ @ b1
                       (c :: Language.Expression -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     case ds2
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a -> b, s, [Language.Expression])>_R) of wild { (,,) f s' w2 ->
                     GHC.Base.foldr @ Language.Expression @ b1 c n w2 })
                    (case ds3
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s, [Language.Expression])>_R) of wild { (,,) x s'' w' ->
                     w' }))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(b, s, [Language.Expression])>_R)))
                  `cast`
                (forall (r :: <*>_N) (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.RWS.Lazy.RWST
                    r
                    [Language.Expression]
                    s
                    Data.Functor.Identity.Identity
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                         r [Language.Expression] s Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                               <r>_R
                               <[Language.Expression]>_N
                               <s>_N
                               <Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
25d7ae24095f2e6ce56ca3fb57e5271f
  $s$fApplicativeRWST_$s$fApplicativeRWST_$cpure ::
    a
    -> Control.Monad.Trans.RWS.Lazy.RWST
         r [Language.Expression] s Data.Functor.Identity.Identity a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ r @ s @ a (a1 :: a) (ds :: r) (s1 :: s) ->
                 (a1, s1, GHC.Types.[] @ Language.Expression))
                  `cast`
                (forall (r :: <*>_N) (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R (<r>_R
                       ->_R <s>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <(a, s,
                                       [Language.Expression])>_R)) ; Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                                                                              <r>_R
                                                                              <[Language.Expression]>_N
                                                                              <s>_N
                                                                              <Data.Functor.Identity.Identity>_R
                                                                              <a>_N)) -}
020886fb6b762ca58c8b8258a45a410c
  $s$fApplicativeRWST_$s$fFunctorRWST ::
    GHC.Base.Functor
      (Control.Monad.Trans.RWS.Lazy.RWST
         r w s Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ r @ w @ s.
                  @ (Control.Monad.Trans.RWS.Lazy.RWST
                       r w s Data.Functor.Identity.Identity)
                  (Control.Monad.Trans.RWS.Lazy.$fFunctorRWST_$cfmap
                     @ Data.Functor.Identity.Identity
                     @ r
                     @ w
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.RWS.Lazy.RWST
                               r w s Data.Functor.Identity.Identity b)
                     (eta1 :: r)
                     (eta2 :: s) ->
                   let {
                     ds :: Data.Functor.Identity.Identity (b, s, w)
                     = eta
                         `cast`
                       (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                            <r>_R <w>_N <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                         eta1
                         eta2
                   } in
                   (x,
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, s, w)>_R) of wild { (,,) a1 s' w1 ->
                    s' },
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, s, w)>_R) of wild { (,,) a1 s' w1 ->
                    w1 })
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0] <(a, s, w)>_R)))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.RWS.Lazy.RWST
                           r w s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                                 <r>_R <w>_N <s>_N <Data.Functor.Identity.Identity>_R <a>_N)) -}
026cadda9e0bfff70467d25941fe3553
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s Data.Functor.Identity.Identity)
                  (Transform.$s$fApplicativeStateT_$s$fFunctorStateT @ s)
                  (Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s)
                  (Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT2
                     @ Data.Functor.Identity.Identity
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Functor.Identity.Identity>_R <c>_N))
                  (Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*> @ s)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Lazy.$fApplicativeStateT2
                     @ Data.Functor.Identity.Identity
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity
                     Data.Functor.Identity.$fMonadIdentity
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Lazy.StateT
                      s Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <s>_N <Data.Functor.Identity.Identity>_R <a>_N)) -}
f5681852bf17c4d49f0422f4f4ebaeb4
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(A,1*U))><C(S),1*C1(U(U,U))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b)
                   (s1 :: s) ->
                 k `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                   (case (m1
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                            s1)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
82799c2927f499852f10af3d569a9a0b
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*C1(U),1*U))><L,1*C1(U(1*U,1*U))><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT
                             s Data.Functor.Identity.Identity a)
                   (s1 :: s) ->
                 let {
                   ds2 :: Data.Functor.Identity.Identity (a -> b, s)
                   = ds
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a -> b>_N)
                       s1
                 } in
                 let {
                   ds3 :: Data.Functor.Identity.Identity (a, s)
                   = ds1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       (case ds2
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <(a -> b, s)>_R) of wild { (,) f s' ->
                        s' })
                 } in
                 (case ds2
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a -> b, s)>_R) of wild { (,) f s' ->
                  f (case ds3
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild1 { (,) x s'' ->
                     x }) },
                  case ds3
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(a, s)>_R) of wild { (,) x s'' ->
                  s'' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0] <(b, s)>_R)))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Lazy.StateT
                         s Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
b9b4dd445d31efbe42cec405ea734097
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (a1 :: a) (s1 :: s) -> (a1, s1))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R (<s>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <(a, s)>_R)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                             <s>_N
                                                             <Data.Functor.Identity.Identity>_R
                                                             <a>_N)) -}
fd7a93bbe40ee46e471840fc086daad3
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       s Data.Functor.Identity.Identity)
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap
                     @ Data.Functor.Identity.Identity
                     @ s
                     Data.Functor.Identity.$fFunctorIdentity)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Lazy.StateT
                               s Data.Functor.Identity.Identity b)
                     (eta1 :: s) ->
                   (x,
                    case (eta
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                            eta1)
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(b, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Lazy.StateT
                           s Data.Functor.Identity.Identity b>_R
                   ->_R (<s>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <(a,
                                         s)>_R)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                            <s>_N
                                                            <Data.Functor.Identity.Identity>_R
                                                            <a>_N)) -}
b1a973871c90047edf6f689338b7d163
  $s$fApplicativeWriterT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       [(Language.Variable, Language.Expression)]
                       (Data.Either.Either NGLess.NGError.NGError))
                  (Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT
                     @ [(Language.Variable, Language.Expression)])
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cliftA2
                     @ [(Language.Variable, Language.Expression)]
                     @ (Data.Either.Either NGLess.NGError.NGError)
                     (GHC.Base.$fMonoid[] @ (Language.Variable, Language.Expression))
                     (Data.Either.$fApplicativeEither @ NGLess.NGError.NGError))
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2
                     @ [(Language.Variable, Language.Expression)]
                     @ (Data.Either.Either NGLess.NGError.NGError)
                     (GHC.Base.$fMonoid[] @ (Language.Variable, Language.Expression))
                     (Data.Either.$fApplicativeEither @ NGLess.NGError.NGError))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.Writer.Lazy.WriterT
                      [(Language.Variable, Language.Expression)]
                      (Data.Either.Either NGLess.NGError.NGError)
                      a>_R
                   ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           (Data.Either.Either NGLess.NGError.NGError)
                           b>_R
                   ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <[(Language.Variable, Language.Expression)]>_N
                                 <Data.Either.Either NGLess.NGError.NGError>_R
                                 <b>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [(Language.Variable, Language.Expression)]
                               (Data.Either.Either NGLess.NGError.NGError)
                               a) ->
                   Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>
                     @ b
                     @ a
                     (case eta
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <[(Language.Variable, Language.Expression)]>_N
                                <Data.Either.Either NGLess.NGError.NGError>_R
                                <a>_N) of wild {
                        Data.Either.Left x
                        -> (Data.Either.Left
                              @ NGLess.NGError.NGError
                              @ (b -> a, [(Language.Variable, Language.Expression)])
                              x)
                             `cast`
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <[(Language.Variable, Language.Expression)]>_N
                                     <Data.Either.Either NGLess.NGError.NGError>_R
                                     <b -> a>_N))
                        Data.Either.Right y
                        -> (Data.Either.Right
                              @ NGLess.NGError.NGError
                              @ (b -> a, [(Language.Variable, Language.Expression)])
                              (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                                 @ b
                                 @ [(Language.Variable, Language.Expression)]
                                 @ a
                                 y))
                             `cast`
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <[(Language.Variable, Language.Expression)]>_N
                                     <Data.Either.Either NGLess.NGError.NGError>_R
                                     <b -> a>_N)) })) -}
c5b7f99cf4d0b61554a49c2f05d5c24d
  $s$fApplicativeWriterT1 ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       [Language.Variable] Data.Functor.Identity.Identity)
                  (Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT1
                     @ [Language.Variable])
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure1
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>1
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cliftA2
                     @ [Language.Variable]
                     @ Data.Functor.Identity.Identity
                     (GHC.Base.$fMonoid[] @ Language.Variable)
                     Data.Functor.Identity.$fApplicativeIdentity)
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2
                     @ [Language.Variable]
                     @ Data.Functor.Identity.Identity
                     (GHC.Base.$fMonoid[] @ Language.Variable)
                     Data.Functor.Identity.$fApplicativeIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.Writer.Lazy.WriterT
                      [Language.Variable] Data.Functor.Identity.Identity a>_R
                   ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                           [Language.Variable] Data.Functor.Identity.Identity b>_R
                   ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <[Language.Variable]>_N <Data.Functor.Identity.Identity>_R <b>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [Language.Variable] Data.Functor.Identity.Identity a) ->
                   Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>1
                     @ b
                     @ a
                     (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                        @ b
                        @ [Language.Variable]
                        @ a
                        eta
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <[Language.Variable]>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <(a, [Language.Variable])>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <(b -> a,
                                 [Language.Variable])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                     <[Language.Variable]>_N
                                                                     <Data.Functor.Identity.Identity>_R
                                                                     <b -> a>_N))) -}
e59e8f6aef9bd873358d85c18f3feb2f
  $s$fApplicativeWriterT2 ::
    GHC.Base.Applicative
      (Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       [(Language.Variable, Language.Expression)]
                       Data.Functor.Identity.Identity)
                  (Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT1
                     @ [(Language.Variable, Language.Expression)])
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure2
                  Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>2
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cliftA2
                     @ [(Language.Variable, Language.Expression)]
                     @ Data.Functor.Identity.Identity
                     (GHC.Base.$fMonoid[] @ (Language.Variable, Language.Expression))
                     Data.Functor.Identity.$fApplicativeIdentity)
                  (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2
                     @ [(Language.Variable, Language.Expression)]
                     @ Data.Functor.Identity.Identity
                     (GHC.Base.$fMonoid[] @ (Language.Variable, Language.Expression))
                     Data.Functor.Identity.$fApplicativeIdentity)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.Writer.Lazy.WriterT
                      [(Language.Variable, Language.Expression)]
                      Data.Functor.Identity.Identity
                      a>_R
                   ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           Data.Functor.Identity.Identity
                           b>_R
                   ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                 <[(Language.Variable, Language.Expression)]>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <b>_N))
                  (\ @ a
                     @ b
                     (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [(Language.Variable, Language.Expression)]
                               Data.Functor.Identity.Identity
                               a) ->
                   Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>2
                     @ b
                     @ a
                     (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                        @ b
                        @ [(Language.Variable, Language.Expression)]
                        @ a
                        eta
                          `cast`
                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                             <[(Language.Variable, Language.Expression)]>_N
                             <Data.Functor.Identity.Identity>_R
                             <a>_N ; Data.Functor.Identity.N:Identity[0]
                                         <(a, [(Language.Variable, Language.Expression)])>_R))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <(b -> a,
                                 [(Language.Variable,
                                   Language.Expression)])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                         <[(Language.Variable,
                                                                            Language.Expression)]>_N
                                                                         <Data.Functor.Identity.Identity>_R
                                                                         <b -> a>_N))) -}
a8d3df3202b5d1f38e588f5d8b86332d
  $s$fApplicativeWriterT3 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      (Data.Either.Either NGLess.NGError.NGError)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         b
    -> Data.Either.Either
         NGLess.NGError.NGError
         (b, [(Language.Variable, Language.Expression)])
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (w3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [(Language.Variable, Language.Expression)]
                            (Data.Either.Either NGLess.NGError.NGError)
                            a)
                   (w4 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [(Language.Variable, Language.Expression)]
                            (Data.Either.Either NGLess.NGError.NGError)
                            b) ->
                 case w3
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <[(Language.Variable, Language.Expression)]>_N
                           <Data.Either.Either NGLess.NGError.NGError>_R
                           <a>_N) of wild {
                   Data.Either.Left x
                   -> Data.Either.Left
                        @ NGLess.NGError.NGError
                        @ (b, [(Language.Variable, Language.Expression)])
                        x
                   Data.Either.Right y
                   -> case w4
                             `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <[(Language.Variable, Language.Expression)]>_N
                                <Data.Either.Either NGLess.NGError.NGError>_R
                                <b>_N) of wild1 {
                        Data.Either.Left x
                        -> Data.Either.Left
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             x
                        Data.Either.Right y1
                        -> Data.Either.Right
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             (case y1 of wild2 { (,) b1 w' -> b1 },
                              GHC.Base.augment
                                @ (Language.Variable, Language.Expression)
                                (\ @ b1
                                   (c :: (Language.Variable, Language.Expression)
                                         -> b1 -> b1)[OneShot]
                                   (n :: b1)[OneShot] ->
                                 case y of wild2 { (,) a1 w1 ->
                                 GHC.Base.foldr
                                   @ (Language.Variable, Language.Expression)
                                   @ b1
                                   c
                                   n
                                   w1 })
                                (case y1 of wild2 { (,) b1 w' -> w' })) } }) -}
6ed25e154b453c2e8f29e1665639db5d
  $s$fApplicativeWriterT_$c<* ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      (Data.Either.Either NGLess.NGError.NGError)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                             [(Language.Variable, Language.Expression)]
                             (Data.Either.Either NGLess.NGError.NGError)
                             a) ->
                 Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>
                   @ b
                   @ a
                   (case eta
                           `cast`
                         (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                              <[(Language.Variable, Language.Expression)]>_N
                              <Data.Either.Either NGLess.NGError.NGError>_R
                              <a>_N) of wild {
                      Data.Either.Left x
                      -> (Data.Either.Left
                            @ NGLess.NGError.NGError
                            @ (b -> a, [(Language.Variable, Language.Expression)])
                            x)
                           `cast`
                         (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <[(Language.Variable, Language.Expression)]>_N
                                   <Data.Either.Either NGLess.NGError.NGError>_R
                                   <b -> a>_N))
                      Data.Either.Right y
                      -> (Data.Either.Right
                            @ NGLess.NGError.NGError
                            @ (b -> a, [(Language.Variable, Language.Expression)])
                            (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                               @ b
                               @ [(Language.Variable, Language.Expression)]
                               @ a
                               y))
                           `cast`
                         (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <[(Language.Variable, Language.Expression)]>_N
                                   <Data.Either.Either NGLess.NGError.NGError>_R
                                   <b -> a>_N)) })) -}
b06cebee1521010152dfa770c3e040af
  $s$fApplicativeWriterT_$c<*1 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [Language.Variable] Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                             [Language.Variable] Data.Functor.Identity.Identity a) ->
                 Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>1
                   @ b
                   @ a
                   (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                      @ b
                      @ [Language.Variable]
                      @ a
                      eta
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <[Language.Variable]>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <(a, [Language.Variable])>_R))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <(b -> a,
                               [Language.Variable])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                   <[Language.Variable]>_N
                                                                   <Data.Functor.Identity.Identity>_R
                                                                   <b -> a>_N))) -}
5991bb234e252f2854bd7facfeb99cfa
  $s$fApplicativeWriterT_$c<*2 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      Data.Functor.Identity.Identity
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ b
                   (eta :: Control.Monad.Trans.Writer.Lazy.WriterT
                             [(Language.Variable, Language.Expression)]
                             Data.Functor.Identity.Identity
                             a) ->
                 Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>2
                   @ b
                   @ a
                   (Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT1
                      @ b
                      @ [(Language.Variable, Language.Expression)]
                      @ a
                      eta
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <[(Language.Variable, Language.Expression)]>_N
                           <Data.Functor.Identity.Identity>_R
                           <a>_N ; Data.Functor.Identity.N:Identity[0]
                                       <(a, [(Language.Variable, Language.Expression)])>_R))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0]
                             <(b -> a,
                               [(Language.Variable,
                                 Language.Expression)])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                       <[(Language.Variable,
                                                                          Language.Expression)]>_N
                                                                       <Data.Functor.Identity.Identity>_R
                                                                       <b -> a>_N))) -}
7c5ab332cace52ca7912574bf1cb0667
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      (Data.Either.Either NGLess.NGError.NGError)
      (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           (Data.Either.Either NGLess.NGError.NGError)
                           (a -> b))
                   (v :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           (Data.Either.Either NGLess.NGError.NGError)
                           a) ->
                 case f `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <[(Language.Variable, Language.Expression)]>_N
                           <Data.Either.Either NGLess.NGError.NGError>_R
                           <a -> b>_N) of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ NGLess.NGError.NGError
                        @ (b, [(Language.Variable, Language.Expression)])
                        x1
                   Data.Either.Right y
                   -> case v `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <[(Language.Variable, Language.Expression)]>_N
                                <Data.Either.Either NGLess.NGError.NGError>_R
                                <a>_N) of wild1 {
                        Data.Either.Left x
                        -> Data.Either.Left
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             x
                        Data.Either.Right y1
                        -> Data.Either.Right
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             (case y of wild2 { (,) a1 w1 ->
                              a1 (case y1 of wild3 { (,) b1 w' -> b1 }) },
                              case y of wild2 { (,) a1 w1 ->
                              GHC.Base.augment
                                @ (Language.Variable, Language.Expression)
                                (\ @ b1
                                   (c :: (Language.Variable, Language.Expression)
                                         -> b1 -> b1)[OneShot]
                                   (n :: b1)[OneShot] ->
                                 GHC.Base.foldr
                                   @ (Language.Variable, Language.Expression)
                                   @ b1
                                   c
                                   n
                                   w1)
                                (case y1 of wild3 { (,) b1 w' -> w' }) }) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [(Language.Variable, Language.Expression)]
                    (Data.Either.Either NGLess.NGError.NGError)
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [(Language.Variable, Language.Expression)]
                         (Data.Either.Either NGLess.NGError.NGError)
                         a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Either.Either NGLess.NGError.NGError>_R
                               <b>_N)) -}
572e3698492ac97b42a686c6a29f5cb9
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>1 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [Language.Variable] Data.Functor.Identity.Identity (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*C1(U),1*U)><L,U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [Language.Variable] Data.Functor.Identity.Identity (a -> b))
                   (v :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [Language.Variable] Data.Functor.Identity.Identity a) ->
                 (case f `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[Language.Variable]>_N
                            <Data.Functor.Identity.Identity>_R
                            <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                             <(a -> b,
                                               [Language.Variable])>_R) of wild { (,) a1 w1 ->
                  a1
                    (case v `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[Language.Variable]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a, [Language.Variable])>_R) of wild1 { (,) b1 w' ->
                     b1 }) },
                  case f `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[Language.Variable]>_N
                            <Data.Functor.Identity.Identity>_R
                            <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                             <(a -> b,
                                               [Language.Variable])>_R) of wild { (,) a1 w1 ->
                  GHC.Base.augment
                    @ Language.Variable
                    (\ @ b1
                       (c :: Language.Variable -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     GHC.Base.foldr @ Language.Variable @ b1 c n w1)
                    (case v `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[Language.Variable]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a, [Language.Variable])>_R) of wild1 { (,) b1 w' ->
                     w' }) }))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [Language.Variable] Data.Functor.Identity.Identity (a -> b)>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [Language.Variable] Data.Functor.Identity.Identity a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(b,
                                 [Language.Variable])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                     <[Language.Variable]>_N
                                                                     <Data.Functor.Identity.Identity>_R
                                                                     <b>_N)) -}
208d63d28a8b6cb3daeb43ebf2241b78
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>2 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      Data.Functor.Identity.Identity
      (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*C1(U),1*U)><L,U(1*U,1*U)>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (f :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           Data.Functor.Identity.Identity
                           (a -> b))
                   (v :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           Data.Functor.Identity.Identity
                           a) ->
                 (case f `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[(Language.Variable, Language.Expression)]>_N
                            <Data.Functor.Identity.Identity>_R
                            <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                             <(a -> b,
                                               [(Language.Variable,
                                                 Language.Expression)])>_R) of wild { (,) a1 w1 ->
                  a1
                    (case v `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a,
                                             [(Language.Variable,
                                               Language.Expression)])>_R) of wild1 { (,) b1 w' ->
                     b1 }) },
                  case f `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[(Language.Variable, Language.Expression)]>_N
                            <Data.Functor.Identity.Identity>_R
                            <a -> b>_N ; Data.Functor.Identity.N:Identity[0]
                                             <(a -> b,
                                               [(Language.Variable,
                                                 Language.Expression)])>_R) of wild { (,) a1 w1 ->
                  GHC.Base.augment
                    @ (Language.Variable, Language.Expression)
                    (\ @ b1
                       (c :: (Language.Variable, Language.Expression)
                             -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     GHC.Base.foldr
                       @ (Language.Variable, Language.Expression)
                       @ b1
                       c
                       n
                       w1)
                    (case v `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a,
                                             [(Language.Variable,
                                               Language.Expression)])>_R) of wild1 { (,) b1 w' ->
                     w' }) }))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [(Language.Variable, Language.Expression)]
                    Data.Functor.Identity.Identity
                    (a -> b)>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [(Language.Variable, Language.Expression)]
                         Data.Functor.Identity.Identity
                         a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(b,
                                 [(Language.Variable,
                                   Language.Expression)])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                         <[(Language.Variable,
                                                                            Language.Expression)]>_N
                                                                         <Data.Functor.Identity.Identity>_R
                                                                         <b>_N)) -}
1b2e2e809dde151d16cb5a479640eab8
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (a1 :: a) ->
                 Data.Either.Right
                   @ NGLess.NGError.NGError
                   @ (a, [(Language.Variable, Language.Expression)])
                   (a1, GHC.Types.[] @ (Language.Variable, Language.Expression)))
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Either.Either NGLess.NGError.NGError>_R
                               <a>_N)) -}
b12502f4f4bbe7367dd24b95678ff8f9
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure1 ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (a1 :: a) -> (a1, GHC.Types.[] @ Language.Variable))
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(a,
                                 [Language.Variable])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                     <[Language.Variable]>_N
                                                                     <Data.Functor.Identity.Identity>_R
                                                                     <a>_N)) -}
5f65d56fd8a26c08fa1927583127743c
  $s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure2 ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (a1 :: a) ->
                 (a1, GHC.Types.[] @ (Language.Variable, Language.Expression)))
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(a,
                                 [(Language.Variable,
                                   Language.Expression)])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                         <[(Language.Variable,
                                                                            Language.Expression)]>_N
                                                                         <Data.Functor.Identity.Identity>_R
                                                                         <a>_N)) -}
c5ce616780db58e2f52533114edfe354
  $s$fApplicativeWriterT_$s$fFunctorWriterT ::
    GHC.Base.Functor
      (Control.Monad.Trans.Writer.Lazy.WriterT
         w (Data.Either.Either NGLess.NGError.NGError))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ w.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       w (Data.Either.Either NGLess.NGError.NGError))
                  (Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap @ w)
                  (\ @ a @ b (x :: a) ->
                   Control.Monad.Trans.Writer.Lazy.mapWriterT
                     @ (Data.Either.Either NGLess.NGError.NGError)
                     @ b
                     @ w
                     @ (Data.Either.Either NGLess.NGError.NGError)
                     @ a
                     @ w
                     (\ (ds1 :: Data.Either.Either NGLess.NGError.NGError (b, w)) ->
                      case ds1 of wild {
                        Data.Either.Left x1
                        -> Data.Either.Left @ NGLess.NGError.NGError @ (a, w) x1
                        Data.Either.Right y
                        -> Data.Either.Right
                             @ NGLess.NGError.NGError
                             @ (a, w)
                             (x, case y of wild1 { (,) a1 w1 -> w1 }) })) -}
67ae11874f1445a7a25cb696e8b822e0
  $s$fApplicativeWriterT_$s$fFunctorWriterT1 ::
    GHC.Base.Functor
      (Control.Monad.Trans.Writer.Lazy.WriterT
         w Data.Functor.Identity.Identity)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ w.
                  @ (Control.Monad.Trans.Writer.Lazy.WriterT
                       w Data.Functor.Identity.Identity)
                  (Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap1 @ w)
                  (\ @ a @ b (x :: a) ->
                   Control.Monad.Trans.Writer.Lazy.mapWriterT
                     @ Data.Functor.Identity.Identity
                     @ b
                     @ w
                     @ Data.Functor.Identity.Identity
                     @ a
                     @ w
                     (\ (ds :: (b, w)) -> (x, case ds of wild { (,) a1 w1 -> w1 }))
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0] <(b, w)>_R)
                      ->_R Sym (Data.Functor.Identity.N:Identity[0] <(a, w)>_R))) -}
f1a82105d23723c29aa3bf8ecab50a70
  $s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w (Data.Either.Either NGLess.NGError.NGError) a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w (Data.Either.Either NGLess.NGError.NGError) b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Data.Either.Either NGLess.NGError.NGError)
                   @ a
                   @ w
                   @ (Data.Either.Either NGLess.NGError.NGError)
                   @ b
                   @ w
                   (\ (ds1 :: Data.Either.Either NGLess.NGError.NGError (a, w)) ->
                    case ds1 of wild {
                      Data.Either.Left x
                      -> Data.Either.Left @ NGLess.NGError.NGError @ (b, w) x
                      Data.Either.Right y
                      -> Data.Either.Right
                           @ NGLess.NGError.NGError
                           @ (b, w)
                           (f (case y of wild1 { (,) a1 w1 -> a1 }),
                            case y of wild1 { (,) a1 w1 -> w1 }) })) -}
05330c362a58c87f7ed759ac085cde03
  $s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap1 ::
    (a -> b)
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U(1*U,1*U)>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ w @ a @ b (f :: a -> b) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ Data.Functor.Identity.Identity
                   @ a
                   @ w
                   @ Data.Functor.Identity.Identity
                   @ b
                   @ w
                   (\ (ds :: (a, w)) ->
                    (f (case ds of wild { (,) a1 w1 -> a1 }),
                     case ds of wild { (,) a1 w1 -> w1 }))
                     `cast`
                   (Sym (Data.Functor.Identity.N:Identity[0] <(a, w)>_R)
                    ->_R Sym (Data.Functor.Identity.N:Identity[0] <(b, w)>_R))) -}
cbe9f30f374ec1bb7c675fb03a4b4128
  $s$fFunctorWriterT_$c<$ ::
    a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w (Data.Either.Either NGLess.NGError.NGError) b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         w (Data.Either.Either NGLess.NGError.NGError) a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ w @ a @ b (x :: a) ->
                 Control.Monad.Trans.Writer.Lazy.mapWriterT
                   @ (Data.Either.Either NGLess.NGError.NGError)
                   @ b
                   @ w
                   @ (Data.Either.Either NGLess.NGError.NGError)
                   @ a
                   @ w
                   (\ (ds1 :: Data.Either.Either NGLess.NGError.NGError (b, w)) ->
                    case ds1 of wild {
                      Data.Either.Left x1
                      -> Data.Either.Left @ NGLess.NGError.NGError @ (a, w) x1
                      Data.Either.Right y
                      -> Data.Either.Right
                           @ NGLess.NGError.NGError
                           @ (a, w)
                           (x, case y of wild1 { (,) a1 w1 -> w1 }) })) -}
135ffcd690d19568a20c7f0f84115e56
  $s$fMonadRWST_$s$fMonadRWST_$c>>= ::
    Control.Monad.Trans.RWS.Lazy.RWST
      r [Language.Expression] s Data.Functor.Identity.Identity a
    -> (a
        -> Control.Monad.Trans.RWS.Lazy.RWST
             r [Language.Expression] s Data.Functor.Identity.Identity b)
    -> Control.Monad.Trans.RWS.Lazy.RWST
         r [Language.Expression] s Data.Functor.Identity.Identity b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(U(1*U,1*U,1*U)))><L,1*C1(C1(C1(U(1*U,1*U,1*U))))><L,U><L,U>m,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ r
                   @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.RWS.Lazy.RWST
                            r [Language.Expression] s Data.Functor.Identity.Identity a)
                   (k :: a
                         -> Control.Monad.Trans.RWS.Lazy.RWST
                              r [Language.Expression] s Data.Functor.Identity.Identity b)
                   (r1 :: r)
                   (s1 :: s) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (a, s, [Language.Expression])
                   = m1
                       `cast`
                     (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                          <r>_R
                          <[Language.Expression]>_N
                          <s>_N
                          <Data.Functor.Identity.Identity>_R
                          <a>_N)
                       r1
                       s1
                 } in
                 let {
                   ds1 :: Data.Functor.Identity.Identity (b, s, [Language.Expression])
                   = (k (case ds
                                `cast`
                              (Data.Functor.Identity.N:Identity[0]
                                   <(a, s, [Language.Expression])>_R) of wild { (,,) a1 s' w2 ->
                         a1 }))
                       `cast`
                     (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                          <r>_R
                          <[Language.Expression]>_N
                          <s>_N
                          <Data.Functor.Identity.Identity>_R
                          <b>_N)
                       r1
                       (case ds
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <(a, s, [Language.Expression])>_R) of wild { (,,) a1 s' w2 ->
                        s' })
                 } in
                 (case ds1
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(b, s, [Language.Expression])>_R) of wild { (,,) b1 s'' w' ->
                  b1 },
                  case ds1
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(b, s, [Language.Expression])>_R) of wild { (,,) b1 s'' w' ->
                  s'' },
                  GHC.Base.augment
                    @ Language.Expression
                    (\ @ b1
                       (c :: Language.Expression -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s, [Language.Expression])>_R) of wild { (,,) a1 s' w2 ->
                     GHC.Base.foldr @ Language.Expression @ b1 c n w2 })
                    (case ds1
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(b, s, [Language.Expression])>_R) of wild { (,,) b1 s'' w' ->
                     w' }))
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(b, s, [Language.Expression])>_R)))
                  `cast`
                (forall (r :: <*>_N) (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.RWS.Lazy.RWST
                    r [Language.Expression] s Data.Functor.Identity.Identity a>_R
                 ->_R <a
                       -> Control.Monad.Trans.RWS.Lazy.RWST
                            r [Language.Expression] s Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.RWS.Lazy.N:RWST[0]
                               <r>_R
                               <[Language.Expression]>_N
                               <s>_N
                               <Data.Functor.Identity.Identity>_R
                               <b>_N)) -}
b7fbc8d509fd4f3a2077ccb90451f1c5
  $s$fMonadStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT
      s Data.Functor.Identity.Identity a
    -> (a
        -> Control.Monad.Trans.State.Lazy.StateT
             s Data.Functor.Identity.Identity b)
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U(1*U,1*U))><C(C(S)),1*C1(C1(U(U,U)))><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT
                              s Data.Functor.Identity.Identity b)
                   (s1 :: s) ->
                 let {
                   ds :: Data.Functor.Identity.Identity (a, s)
                   = m1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <s>_N <Data.Functor.Identity.Identity>_R <a>_N)
                       s1
                 } in
                 (k (case ds
                            `cast`
                          (Data.Functor.Identity.N:Identity[0]
                               <(a, s)>_R) of wild { (,) a1 s' ->
                     a1 }))
                   `cast`
                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                      <s>_N <Data.Functor.Identity.Identity>_R <b>_N)
                   (case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(a, s)>_R) of wild { (,) a1 s' ->
                    s' }))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Lazy.StateT
                    s Data.Functor.Identity.Identity a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Lazy.StateT
                            s Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <Data.Functor.Identity.Identity>_R <b>_N)) -}
e469317b7f5c213c88b8670ac90f8387
  $s$fMonadWriterT_$s$fMonadWriterT_$c>> ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      (Data.Either.Either NGLess.NGError.NGError)
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         (Data.Either.Either NGLess.NGError.NGError)
         b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [(Language.Variable, Language.Expression)]
                            (Data.Either.Either NGLess.NGError.NGError)
                            a)
                   (k :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           (Data.Either.Either NGLess.NGError.NGError)
                           b) ->
                 case m1
                        `cast`
                      (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                           <[(Language.Variable, Language.Expression)]>_N
                           <Data.Either.Either NGLess.NGError.NGError>_R
                           <a>_N) of wild {
                   Data.Either.Left l
                   -> Data.Either.Left
                        @ NGLess.NGError.NGError
                        @ (b, [(Language.Variable, Language.Expression)])
                        l
                   Data.Either.Right r
                   -> case k `cast`
                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <[(Language.Variable, Language.Expression)]>_N
                                <Data.Either.Either NGLess.NGError.NGError>_R
                                <b>_N) of wild1 {
                        Data.Either.Left l
                        -> Data.Either.Left
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             l
                        Data.Either.Right r1
                        -> Data.Either.Right
                             @ NGLess.NGError.NGError
                             @ (b, [(Language.Variable, Language.Expression)])
                             (case r1 of wild2 { (,) b1 w' -> b1 },
                              GHC.Base.augment
                                @ (Language.Variable, Language.Expression)
                                (\ @ b1
                                   (c :: (Language.Variable, Language.Expression)
                                         -> b1 -> b1)[OneShot]
                                   (n :: b1)[OneShot] ->
                                 case r of wild2 { (,) a1 w2 ->
                                 GHC.Base.foldr
                                   @ (Language.Variable, Language.Expression)
                                   @ b1
                                   c
                                   n
                                   w2 })
                                (case r1 of wild2 { (,) b1 w' -> w' })) } })
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [(Language.Variable, Language.Expression)]
                    (Data.Either.Either NGLess.NGError.NGError)
                    a>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [(Language.Variable, Language.Expression)]
                         (Data.Either.Either NGLess.NGError.NGError)
                         b>_R
                 ->_R Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Either.Either NGLess.NGError.NGError>_R
                               <b>_N)) -}
664740277696ddfd6a5383849c7f3551
  $s$fMonadWriterT_$s$fMonadWriterT_$c>>1 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [Language.Variable] Data.Functor.Identity.Identity a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [Language.Variable] Data.Functor.Identity.Identity b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U)><L,U(1*U,1*U)>m, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [Language.Variable] Data.Functor.Identity.Identity a)
                   (k :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [Language.Variable] Data.Functor.Identity.Identity b) ->
                 (case k `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[Language.Variable]>_N
                            <Data.Functor.Identity.Identity>_R
                            <b>_N ; Data.Functor.Identity.N:Identity[0]
                                        <(b, [Language.Variable])>_R) of wild { (,) b1 w' ->
                  b1 },
                  GHC.Base.augment
                    @ Language.Variable
                    (\ @ b1
                       (c :: Language.Variable -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     case m1
                            `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[Language.Variable]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a, [Language.Variable])>_R) of wild { (,) a1 w2 ->
                     GHC.Base.foldr @ Language.Variable @ b1 c n w2 })
                    (case k `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[Language.Variable]>_N
                               <Data.Functor.Identity.Identity>_R
                               <b>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(b, [Language.Variable])>_R) of wild { (,) b1 w' ->
                     w' })))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [Language.Variable] Data.Functor.Identity.Identity a>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [Language.Variable] Data.Functor.Identity.Identity b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(b,
                                 [Language.Variable])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                     <[Language.Variable]>_N
                                                                     <Data.Functor.Identity.Identity>_R
                                                                     <b>_N)) -}
42330f37cd3c85cb568c52c5f1500cc2
  $s$fMonadWriterT_$s$fMonadWriterT_$c>>2 ::
    Control.Monad.Trans.Writer.Lazy.WriterT
      [(Language.Variable, Language.Expression)]
      Data.Functor.Identity.Identity
      a
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         b
    -> Control.Monad.Trans.Writer.Lazy.WriterT
         [(Language.Variable, Language.Expression)]
         Data.Functor.Identity.Identity
         b
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,1*U)><L,U(1*U,1*U)>m, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [(Language.Variable, Language.Expression)]
                            Data.Functor.Identity.Identity
                            a)
                   (k :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [(Language.Variable, Language.Expression)]
                           Data.Functor.Identity.Identity
                           b) ->
                 (case k `cast`
                       (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                            <[(Language.Variable, Language.Expression)]>_N
                            <Data.Functor.Identity.Identity>_R
                            <b>_N ; Data.Functor.Identity.N:Identity[0]
                                        <(b,
                                          [(Language.Variable,
                                            Language.Expression)])>_R) of wild { (,) b1 w' ->
                  b1 },
                  GHC.Base.augment
                    @ (Language.Variable, Language.Expression)
                    (\ @ b1
                       (c :: (Language.Variable, Language.Expression)
                             -> b1 -> b1)[OneShot]
                       (n :: b1)[OneShot] ->
                     case m1
                            `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Functor.Identity.Identity>_R
                               <a>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(a,
                                             [(Language.Variable,
                                               Language.Expression)])>_R) of wild { (,) a1 w2 ->
                     GHC.Base.foldr
                       @ (Language.Variable, Language.Expression)
                       @ b1
                       c
                       n
                       w2 })
                    (case k `cast`
                          (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                               <[(Language.Variable, Language.Expression)]>_N
                               <Data.Functor.Identity.Identity>_R
                               <b>_N ; Data.Functor.Identity.N:Identity[0]
                                           <(b,
                                             [(Language.Variable,
                                               Language.Expression)])>_R) of wild { (,) b1 w' ->
                     w' })))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.Writer.Lazy.WriterT
                    [(Language.Variable, Language.Expression)]
                    Data.Functor.Identity.Identity
                    a>_R
                 ->_R <Control.Monad.Trans.Writer.Lazy.WriterT
                         [(Language.Variable, Language.Expression)]
                         Data.Functor.Identity.Identity
                         b>_R
                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                               <(b,
                                 [(Language.Variable,
                                   Language.Expression)])>_R) ; Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                                         <[(Language.Variable,
                                                                            Language.Expression)]>_N
                                                                         <Data.Functor.Identity.Identity>_R
                                                                         <b>_N)) -}
15846b799c59675f1f2186312bfd1696
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Transform.$trModule3
                   Transform.$trModule1) -}
2568669d09c7dd377a598e722603b998
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Transform.$trModule2) -}
e65b53b4197865be9c537a609ef57d42
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Transform"#) -}
cd1dfaff36a6d9c8a31b51820878109e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Transform.$trModule4) -}
42560ba67e08949953e54f3fa5300895
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5"#) -}
3b5d58f0d409d1f623c293ff176eb97d
  $w$sgo8 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Internal.Map Language.Variable a1
    -> Data.Map.Internal.Map Language.Variable a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><S,1*U>,
     Inline: [2] -}
86aa882cfdcd465d0b71dbe6216e7bb5
  $waddFileChecks' ::
    Data.Text.Internal.Text
    -> Modules.ArgCheck
    -> [(GHC.Types.Int, Language.Expression)]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 4, Strictness: <L,U><L,U><S,1*U><S,U>, Inline: [2] -}
dc7cee043826d23b1f2aa5b342cc7d76
  $waddOutputHash ::
    [(GHC.Types.Int, Language.Expression)]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2] -}
e868118bb752f2036482a581a20ea479
  $waddTemporaries1 ::
    [Modules.Module]
    -> GHC.Types.Int
    -> Language.Expression
    -> (# GHC.Types.Int, [Language.Expression] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [2] -}
f78535b6a8c51109dc1b133e2d4b9051
  $wgo13 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map Language.Variable a
    -> GHC.Maybe.Maybe a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [2] -}
d9738b4f79c94ea888abfe47ff13643a
  $wreassignPreprocess ::
    [(GHC.Types.Int, Language.Expression)]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [2],
     Unfolding: (\ (w :: [(GHC.Types.Int, Language.Expression)])
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case NGLess.NGLEnvironment.ngle
                        `cast`
                      (GHC.IORef.N:IORef[0] <NGLess.NGLEnvironment.NGLEnvironment>_N) of wild { GHC.STRef.STRef var# ->
                 case GHC.Prim.readMutVar#
                        @ GHC.Prim.RealWorld
                        @ NGLess.NGLEnvironment.NGLEnvironment
                        var#
                        w1 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild1 { NGLess.NGLEnvironment.NGLEnvironment ds2 ds3 ds4 ds5 ds6 ds7 ->
                 case ds2 of wild2 { NGLess.NGLEnvironment.NGLVersion dt dt1 ->
                 case dt of ds {
                   DEFAULT -> case w of vx { DEFAULT -> (# ipv, vx #) }
                   0#
                   -> case dt1 of ds8 {
                        DEFAULT -> case w of vx { DEFAULT -> (# ipv, vx #) }
                        0#
                        -> case GHC.Base.map
                                  @ (GHC.Types.Int, Language.Expression)
                                  @ (GHC.Types.Int, Language.Expression)
                                  (\ (ds9 :: (GHC.Types.Int, Language.Expression)) ->
                                   (case ds9 of wild3 { (,) x y -> x },
                                    case ds9 of wild3 { (,) x y ->
                                    case y of wild4 {
                                      DEFAULT -> wild4
                                      Language.FunctionCall ds10 ds11 ds12 ds13
                                      -> case ds10
                                                `cast`
                                              (Language.N:FuncName[0]) of wild5 { Data.Text.Internal.Text dt2 dt3 dt4 ->
                                         case Data.Text.Show.unpackCString#
                                                "preprocess"# of wild6 { Data.Text.Internal.Text dt5 dt6 dt7 ->
                                         case GHC.Prim.==# dt4 dt7 of lwild {
                                           DEFAULT -> wild4
                                           1#
                                           -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.ByteArray#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.State#
                                                                                  GHC.Prim.RealWorld
                                                                             -> (# GHC.Prim.State#
                                                                                     GHC.Prim.RealWorld,
                                                                                   GHC.Prim.Int# #)}
                                                     dt2
                                                     (GHC.Prim.int2Word# dt3)
                                                     dt5
                                                     (GHC.Prim.int2Word# dt6)
                                                     (GHC.Prim.int2Word# dt4)
                                                     GHC.Prim.realWorld# of wild7 { (#,#) ds14 ds15 ->
                                              case GHC.Prim.narrow32Int# ds15 of wild8 {
                                                DEFAULT -> wild4
                                                0#
                                                -> case ds11 of wild9 {
                                                     DEFAULT -> wild4
                                                     Language.Lookup ds16 v
                                                     -> Language.Assignment
                                                          v
                                                          wild4 } } } } } } } }))
                                  w of vx { DEFAULT ->
                           (# ipv, vx #) } } } } } } }) -}
6715bd4854af474fe36ad44ccc9ecfc3
  addCountsCheck ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.List.reverse1
                       @ (GHC.Types.Int, Language.Expression)
                       (Transform.transform_$sgenericCheckUpfloat'1
                          (GHC.List.reverse1
                             @ (GHC.Types.Int, Language.Expression)
                             x
                             (GHC.Types.[] @ (GHC.Types.Int, Language.Expression))))
                       (GHC.Types.[] @ (GHC.Types.Int, Language.Expression))
                 } in
                 (\ (eta1 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta2, eta #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
f6608045bd23aaba0efcca1f0b85e79d
  addFileChecks ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (sc :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   ds :: Data.Text.Internal.Text
                   = Data.Text.Show.unpackCString# "__check_ifile"#
                 } in
                 let {
                   ds1 :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.List.reverse1
                       @ (GHC.Types.Int, Language.Expression)
                       sc
                       (GHC.Types.[] @ (GHC.Types.Int, Language.Expression))
                 } in
                 let {
                   f :: Data.Text.Internal.Text
                   = Data.Text.Show.unpackCString# "__check_ofile"#
                 } in
                 (\ (r :: GHC.IORef.IORef
                            Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case Transform.$waddFileChecks'
                         ds
                         Modules.ArgCheckFileReadable
                         ds1
                         s of ds2 { (#,#) ipv ipv1 ->
                  case Transform.$waddFileChecks'
                         f
                         Modules.ArgCheckFileWritable
                         ipv1
                         ipv of ds3 { (#,#) ipv2 ipv3 ->
                  (# ipv2,
                     GHC.List.reverse
                       @ (GHC.Types.Int, Language.Expression)
                       ipv3 #) } })
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
9c73b4c3859a5fa9767612edf42ca58a
  addIndexChecks ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.List.reverse1
                       @ (GHC.Types.Int, Language.Expression)
                       (Transform.transform_$sgenericCheckUpfloat'
                          (GHC.List.reverse1
                             @ (GHC.Types.Int, Language.Expression)
                             x
                             (GHC.Types.[] @ (GHC.Types.Int, Language.Expression))))
                       (GHC.Types.[] @ (GHC.Types.Int, Language.Expression))
                 } in
                 (\ (eta1 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta2, eta #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
db9bed59c082be10a1f55702035c508b
  ifLenDiscardSpecial ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (eta :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta1 :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.Base.map
                       @ (GHC.Types.Int, Language.Expression)
                       @ (GHC.Types.Int, Language.Expression)
                       (\ (ds :: (GHC.Types.Int, Language.Expression)) ->
                        (case ds of wild { (,) x y -> x },
                         (Language.$wrecursiveTransform
                            @ Data.Functor.Identity.Identity
                            Data.Functor.Identity.$fApplicativeIdentity
                            Data.Functor.Identity.$fMonadIdentity_$c>>=
                            Data.Functor.Identity.$fApplicativeIdentity3
                              `cast`
                            (forall (a :: <*>_N).
                             <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                            Transform.transform4
                              `cast`
                            (<Language.Expression>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Language.Expression>_R))
                            (case ds of wild { (,) x y -> y }))
                           `cast`
                         (Data.Functor.Identity.N:Identity[0] <Language.Expression>_R)))
                       eta
                 } in
                 (\ (eta2 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta3, eta1 #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
1c27ba939cd12138426a63349d45f8ac
  isVarUsed ::
    Language.Variable
    -> [(GHC.Types.Int, Language.Expression)] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U,U)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Transform.isVarUsed2
                  `cast`
                (<Language.Variable>_R
                 ->_R <[(GHC.Types.Int, Language.Expression)]>_R
                 ->_R Data.Semigroup.Internal.N:Any[0]) -}
aa65624df743e8747ae12bc1eb22535d
  isVarUsed1 ::
    Language.Variable -> Language.Expression -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Transform.isVarUsed3
                  `cast`
                (<Language.Variable>_R
                 ->_R <Language.Expression>_R
                 ->_R Data.Functor.Identity.N:Identity[0] <GHC.Types.Bool>_R) -}
52044e6bc62cfc4f82810393e5748719
  isVarUsed2 ::
    Language.Variable
    -> [(GHC.Types.Int, Language.Expression)]
    -> Data.Semigroup.Internal.Any
  {- Arity: 2, Strictness: <L,U(U,U,U)><S,1*U>,
     Unfolding: (\ (v :: Language.Variable)
                   (eta :: [(GHC.Types.Int, Language.Expression)]) ->
                 letrec {
                   go :: [(GHC.Types.Int, Language.Expression)]
                         -> Data.Semigroup.Internal.Any
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(GHC.Types.Int, Language.Expression)]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:Any[0]))
                       : y ys
                       -> case (Transform.isVarUsed3
                                  v
                                  (Data.Tuple.snd @ GHC.Types.Int @ Language.Expression y))
                                 `cast`
                               (Data.Functor.Identity.N:Identity[0] <GHC.Types.Bool>_R) of wild1 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> GHC.Types.True
                                 `cast`
                               (Sym (Data.Semigroup.Internal.N:Any[0])) } }
                 } in
                 go eta) -}
dc478e6874da26c37c4342e4308c5b18
  isVarUsed3 ::
    Language.Variable
    -> Language.Expression
    -> Data.Functor.Identity.Identity GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U>,
     Unfolding: (\ (v :: Language.Variable)
                   (expr :: Language.Expression) ->
                 (Language.$wrecursiveAnalyse
                    @ (Control.Monad.Trans.Cont.ContT
                         GHC.Types.Bool Data.Functor.Identity.Identity)
                    (Control.Monad.Trans.Cont.$fApplicativeContT
                       @ *
                       @ GHC.Types.Bool
                       @ Data.Functor.Identity.Identity)
                    (Control.Monad.Trans.Cont.$fMonadContT_$c>>
                       @ *
                       @ GHC.Types.Bool
                       @ Data.Functor.Identity.Identity)
                    (Control.Monad.Trans.Cont.$fApplicativeContT_$cpure
                       @ *
                       @ GHC.Types.Bool
                       @ Data.Functor.Identity.Identity)
                    (\ (ds :: Language.Expression) ->
                     case ds of wild {
                       DEFAULT
                       -> (\ (ds1 :: ()
                                     -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                           ds1 GHC.Tuple.())
                            `cast`
                          (Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                    <*>_N
                                    <GHC.Types.Bool>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_R))
                       Language.Lookup ds1 v'
                       -> case v `cast`
                               (Language.N:Variable[0]) of wild1 { Data.Text.Internal.Text dt dt1 dt2 ->
                          case v'
                                 `cast`
                               (Language.N:Variable[0]) of wild2 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                          case GHC.Prim.==# dt2 dt5 of lwild {
                            DEFAULT
                            -> (\ (ds2 :: ()
                                          -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                ds2 GHC.Tuple.())
                                 `cast`
                               (Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                         <*>_N
                                         <GHC.Types.Bool>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_R))
                            1#
                            -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.ByteArray#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.State# GHC.Prim.RealWorld
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Int# #)}
                                      dt
                                      (GHC.Prim.int2Word# dt1)
                                      dt3
                                      (GHC.Prim.int2Word# dt4)
                                      (GHC.Prim.int2Word# dt2)
                                      GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                               case GHC.Prim.narrow32Int# ds3 of wild3 {
                                 DEFAULT
                                 -> (\ (ds5 :: ()
                                               -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                     ds5 GHC.Tuple.())
                                      `cast`
                                    (Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                              <*>_N
                                              <GHC.Types.Bool>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <()>_R))
                                 0#
                                 -> (\ (ds5 :: ()
                                               -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                     GHC.Types.True)
                                      `cast`
                                    ((<() -> Data.Functor.Identity.Identity GHC.Types.Bool>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                    <GHC.Types.Bool>_R)) ; Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                                                                    <*>_N
                                                                                    <GHC.Types.Bool>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <()>_R)) } } } } }
                       Language.Assignment v' ds1
                       -> case v `cast`
                               (Language.N:Variable[0]) of wild1 { Data.Text.Internal.Text dt dt1 dt2 ->
                          case v'
                                 `cast`
                               (Language.N:Variable[0]) of wild2 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                          case GHC.Prim.==# dt2 dt5 of lwild {
                            DEFAULT
                            -> (\ (ds2 :: ()
                                          -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                ds2 GHC.Tuple.())
                                 `cast`
                               (Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                         <*>_N
                                         <GHC.Types.Bool>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <()>_R))
                            1#
                            -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.ByteArray#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.Word#
                                                              -> GHC.Prim.State# GHC.Prim.RealWorld
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Int# #)}
                                      dt
                                      (GHC.Prim.int2Word# dt1)
                                      dt3
                                      (GHC.Prim.int2Word# dt4)
                                      (GHC.Prim.int2Word# dt2)
                                      GHC.Prim.realWorld# of wild5 { (#,#) ds2 ds3 ->
                               case GHC.Prim.narrow32Int# ds3 of wild3 {
                                 DEFAULT
                                 -> (\ (ds5 :: ()
                                               -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                     ds5 GHC.Tuple.())
                                      `cast`
                                    (Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                              <*>_N
                                              <GHC.Types.Bool>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <()>_R))
                                 0#
                                 -> (\ (ds5 :: ()
                                               -> Data.Functor.Identity.Identity GHC.Types.Bool) ->
                                     GHC.Types.True)
                                      `cast`
                                    ((<() -> Data.Functor.Identity.Identity GHC.Types.Bool>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                    <GHC.Types.Bool>_R)) ; Sym (Control.Monad.Trans.Cont.N:ContT[0]
                                                                                    <*>_N
                                                                                    <GHC.Types.Bool>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <()>_R)) } } } } } })
                    expr)
                   `cast`
                 (Control.Monad.Trans.Cont.N:ContT[0]
                      <*>_N <GHC.Types.Bool>_N <Data.Functor.Identity.Identity>_R <()>_R)
                   (\ (x :: ()) -> GHC.Types.False)
                     `cast`
                   (<()>_R
                    ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                  <GHC.Types.Bool>_R))) -}
18372d25e205bda6cbfcfec9cb360f8d
  pureTransform ::
    (Language.Expression -> Language.Expression)
    -> [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>,
     Unfolding: (\ (f :: Language.Expression -> Language.Expression)
                   (eta :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta1 :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.Base.map
                       @ (GHC.Types.Int, Language.Expression)
                       @ (GHC.Types.Int, Language.Expression)
                       (\ (ds :: (GHC.Types.Int, Language.Expression)) ->
                        (case ds of wild { (,) x y -> x },
                         (Language.$wrecursiveTransform
                            @ Data.Functor.Identity.Identity
                            Data.Functor.Identity.$fApplicativeIdentity
                            Data.Functor.Identity.$fMonadIdentity_$c>>=
                            Data.Functor.Identity.$fApplicativeIdentity3
                              `cast`
                            (forall (a :: <*>_N).
                             <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                            (\ (x :: Language.Expression) -> f x)
                              `cast`
                            (<Language.Expression>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Language.Expression>_R))
                            (case ds of wild { (,) x y -> y }))
                           `cast`
                         (Data.Functor.Identity.N:Identity[0] <Language.Expression>_R)))
                       eta
                 } in
                 (\ (eta2 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta3, eta1 #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
8ebcab66b8b9ce45dd639f5bb6a1e1f1
  qcInPreprocess ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <S,1*U> -}
3b9e2ae82c8c2763f14f275ef67ed533
  substrimReassign ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (eta :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta1 :: [(GHC.Types.Int, Language.Expression)]
                   = GHC.Base.map
                       @ (GHC.Types.Int, Language.Expression)
                       @ (GHC.Types.Int, Language.Expression)
                       (\ (ds :: (GHC.Types.Int, Language.Expression)) ->
                        (case ds of wild { (,) x y -> x },
                         (Language.$wrecursiveTransform
                            @ Data.Functor.Identity.Identity
                            Data.Functor.Identity.$fApplicativeIdentity
                            Data.Functor.Identity.$fMonadIdentity_$c>>=
                            Data.Functor.Identity.$fApplicativeIdentity3
                              `cast`
                            (forall (a :: <*>_N).
                             <a>_R ->_R Sym (Data.Functor.Identity.N:Identity[0] <a>_R))
                            Transform.transform5
                              `cast`
                            (<Language.Expression>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Language.Expression>_R))
                            (case ds of wild { (,) x y -> y }))
                           `cast`
                         (Data.Functor.Identity.N:Identity[0] <Language.Expression>_R)))
                       eta
                 } in
                 (\ (eta2 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta3, eta1 #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
44e7042dd553ba3746930523b4d237cb
  transform ::
    [Modules.Module]
    -> Language.Script -> NGLess.NGError.NGLessIO Language.Script
  {- Arity: 2, Strictness: <L,1*U><L,U(1*U,1*U)>,
     Unfolding: (\ (mods :: [Modules.Module]) (sc :: Language.Script) ->
                 let {
                   f :: GHC.Maybe.Maybe Language.Header
                   = case sc of wild { Language.Script ds1 ds2 -> ds1 }
                 } in
                 letrec {
                   applyM :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                             -> [(GHC.Types.Int, Language.Expression)]
                             -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [[(GHC.Types.Int, Language.Expression)]
                               -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]])
                       (e :: [(GHC.Types.Int, Language.Expression)]) ->
                     case ds of wild {
                       []
                       -> (\ (eta1 :: GHC.IORef.IORef
                                        Control.Monad.Trans.Resource.Internal.ReleaseMap)
                             (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           (# eta2, e #))
                            `cast`
                          ((<GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <[(GHC.Types.Int,
                                             Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                    <GHC.Types.IO>_R
                                                                                    <[(GHC.Types.Int,
                                                                                       Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                         Language.Expression)]>_N))
                       : t ts
                       -> let {
                            ds1 :: NGLess.NGError.NGLessIO
                                     [(GHC.Types.Int, Language.Expression)]
                            = t e
                          } in
                          (\ (r :: GHC.IORef.IORef
                                     Control.Monad.Trans.Resource.Internal.ReleaseMap)
                             (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                           case (ds1
                                   `cast`
                                 (NGLess.NGError.N:NGLessIO[0] <[(GHC.Types.Int,
                                                                  Language.Expression)]>_N ; Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                                 <GHC.Types.IO>_R
                                                                                                 <[(GHC.Types.Int,
                                                                                                    Language.Expression)]>_N)
                                   r)
                                  `cast`
                                (GHC.Types.N:IO[0] <[(GHC.Types.Int, Language.Expression)]>_R)
                                  s of ds2 { (#,#) ipv ipv1 ->
                           ((applyM ts ipv1)
                              `cast`
                            (NGLess.NGError.N:NGLessIO[0] <[(GHC.Types.Int,
                                                             Language.Expression)]>_N ; Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                            <GHC.Types.IO>_R
                                                                                            <[(GHC.Types.Int,
                                                                                               Language.Expression)]>_N)
                              r)
                             `cast`
                           (GHC.Types.N:IO[0] <[(GHC.Types.Int, Language.Expression)]>_R)
                             ipv })
                            `cast`
                          ((<GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <[(GHC.Types.Int,
                                             Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                    <GHC.Types.IO>_R
                                                                                    <[(GHC.Types.Int,
                                                                                       Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                         Language.Expression)]>_N)) }
                 } in
                 let {
                   $sapplyM1 :: [(GHC.Types.Int, Language.Expression)]
                                -> (([(GHC.Types.Int, Language.Expression)]
                                     -> GHC.IORef.IORef
                                          Control.Monad.Trans.Resource.Internal.ReleaseMap
                                     -> GHC.Prim.State# GHC.Prim.RealWorld
                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                           [(GHC.Types.Int, Language.Expression)] #))
                                    ~R# ([(GHC.Types.Int, Language.Expression)]
                                         -> NGLess.NGError.NGLessIO
                                              [(GHC.Types.Int, Language.Expression)])) =>
                                   [[(GHC.Types.Int, Language.Expression)]
                                    -> NGLess.NGError.NGLessIO
                                         [(GHC.Types.Int, Language.Expression)]]
                                   -> GHC.IORef.IORef
                                        Control.Monad.Trans.Resource.Internal.ReleaseMap
                                   -> GHC.Prim.State# GHC.Prim.RealWorld
                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                         [(GHC.Types.Int, Language.Expression)] #)
                     {- Arity: 5, Strictness: <S,1*U><L,A><L,1*U><L,U><S,U> -}
                   = \ (sc1 :: [(GHC.Types.Int, Language.Expression)])
                       (sg :: ([(GHC.Types.Int, Language.Expression)]
                               -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
                               -> GHC.Prim.State# GHC.Prim.RealWorld
                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                     [(GHC.Types.Int, Language.Expression)] #))
                              ~R# ([(GHC.Types.Int, Language.Expression)]
                                   -> NGLess.NGError.NGLessIO
                                        [(GHC.Types.Int, Language.Expression)]))
                       (sc2 :: [[(GHC.Types.Int, Language.Expression)]
                                -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]])
                       (eta :: GHC.IORef.IORef
                                 Control.Monad.Trans.Resource.Internal.ReleaseMap)
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case Transform.$wreassignPreprocess
                            sc1
                            eta1 of ds1 { (#,#) ipv ipv1 ->
                     ((applyM sc2 ipv1)
                        `cast`
                      (NGLess.NGError.N:NGLessIO[0] <[(GHC.Types.Int,
                                                       Language.Expression)]>_N ; Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                      <GHC.Types.IO>_R
                                                                                      <[(GHC.Types.Int,
                                                                                         Language.Expression)]>_N)
                        eta)
                       `cast`
                     (GHC.Types.N:IO[0] <[(GHC.Types.Int, Language.Expression)]>_R)
                       ipv }
                 } in
                 let {
                   ds :: [(GHC.Types.Int, Language.Expression)]
                   = case sc of wild { Language.Script ds1 ds2 -> ds2 }
                 } in
                 let {
                   ds1 :: [[(GHC.Types.Int, Language.Expression)]
                           -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                   = let {
                       z :: [[(GHC.Types.Int, Language.Expression)]
                             -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.addCountsCheck
                           (GHC.Types.[]
                              @ ([(GHC.Types.Int, Language.Expression)]
                                 -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]))
                     } in
                     let {
                       z1 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.transform6
                             `cast`
                           (<[(GHC.Types.Int, Language.Expression)]>_R
                            ->_R (<GHC.IORef.IORef
                                     Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                                  ->_R Sym (GHC.Types.N:IO[0]
                                                <[(GHC.Types.Int,
                                                   Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                          <GHC.Types.IO>_R
                                                                                          <[(GHC.Types.Int,
                                                                                             Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                               Language.Expression)]>_N))
                           z
                     } in
                     let {
                       z2 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.addIndexChecks
                           z1
                     } in
                     let {
                       z3 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.addFileChecks
                           z2
                     } in
                     let {
                       z4 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.substrimReassign
                           z3
                     } in
                     let {
                       z5 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.ifLenDiscardSpecial
                           z4
                     } in
                     let {
                       z6 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.qcInPreprocess
                           z5
                     } in
                     let {
                       z7 :: [[(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                       = GHC.Types.:
                           @ ([(GHC.Types.Int, Language.Expression)]
                              -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                           Transform.writeToMove
                           z6
                     } in
                     letrec {
                       go :: [Modules.Module]
                             -> [[(GHC.Types.Int, Language.Expression)]
                                 -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds2 :: [Modules.Module]) ->
                         case ds2 of wild {
                           [] -> z7
                           : y ys
                           -> GHC.Types.:
                                @ ([(GHC.Types.Int, Language.Expression)]
                                   -> NGLess.NGError.NGLessIO
                                        [(GHC.Types.Int, Language.Expression)])
                                (Modules.modTransform y)
                                (go ys) }
                     } in
                     go mods
                 } in
                 let {
                   ds2 :: [[(GHC.Types.Int, Language.Expression)]
                           -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                   = GHC.Types.:
                       @ ([(GHC.Types.Int, Language.Expression)]
                          -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                       Transform.transform3
                         `cast`
                       (<[(GHC.Types.Int, Language.Expression)]>_R
                        ->_R (<GHC.IORef.IORef
                                 Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <[(GHC.Types.Int,
                                               Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                      <GHC.Types.IO>_R
                                                                                      <[(GHC.Types.Int,
                                                                                         Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                           Language.Expression)]>_N))
                       ds1
                 } in
                 let {
                   ds3 :: [[(GHC.Types.Int, Language.Expression)]
                           -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]]
                   = GHC.Types.:
                       @ ([(GHC.Types.Int, Language.Expression)]
                          -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)])
                       Transform.transform1
                         `cast`
                       (<[(GHC.Types.Int, Language.Expression)]>_R
                        ->_R (<GHC.IORef.IORef
                                 Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <[(GHC.Types.Int,
                                               Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                      <GHC.Types.IO>_R
                                                                                      <[(GHC.Types.Int,
                                                                                         Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                           Language.Expression)]>_N))
                       ds2
                 } in
                 (\ (r :: GHC.IORef.IORef
                            Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  case $sapplyM1
                         ds
                         @~ (<[(GHC.Types.Int, Language.Expression)]>_R
                             ->_R (<GHC.IORef.IORef
                                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                                   ->_R Sym (GHC.Types.N:IO[0]
                                                 <[(GHC.Types.Int,
                                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                                           <GHC.Types.IO>_R
                                                                                           <[(GHC.Types.Int,
                                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                                Language.Expression)]>_N))
                         ds3
                         r
                         s of ds4 { (#,#) ipv ipv1 ->
                  (# ipv, Language.Script f ipv1 #) })
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <Language.Script>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                   <GHC.Types.IO>_R
                                                                   <Language.Script>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <Language.Script>_N))) -}
6470e5fa136c483e30c202e1428b628e
  transform1 ::
    [(GHC.Types.Int, Language.Expression)]
    -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 3, Strictness: <S,1*U><L,A><S,U>,
     Unfolding: (\ (w :: [(GHC.Types.Int, Language.Expression)])
                   (w1 :: GHC.IORef.IORef
                            Control.Monad.Trans.Resource.Internal.ReleaseMap)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of wild {
                   [] -> (# w2, GHC.Types.[] @ (GHC.Types.Int, Language.Expression) #)
                   : ds rest
                   -> case ds of wild1 { (,) lno e ->
                      case Modules.loadedModulesRef
                             `cast`
                           (GHC.IORef.N:IORef[0] <[Modules.Module]>_N) of wild2 { GHC.STRef.STRef var# ->
                      case GHC.Prim.readMutVar#
                             @ GHC.Prim.RealWorld
                             @ [Modules.Module]
                             var#
                             w2 of ds1 { (#,#) ipv ipv1 ->
                      let {
                        ds2 :: (GHC.Types.Int, [Language.Expression])
                        = case Transform.$waddTemporaries1
                                 ipv1
                                 Transform.transform2
                                 e of ww { (#,#) ww1 ww2 ->
                          (ww1, ww2) }
                      } in
                      letrec {
                        $waddTemporaries' :: GHC.Types.Int
                                             -> [(GHC.Types.Int, Language.Expression)]
                                             -> GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   [(GHC.Types.Int, Language.Expression)] #)
                          {- Arity: 3, Strictness: <L,U><S,1*U><S,U>, Inline: [2] -}
                        = \ (w3 :: GHC.Types.Int)
                            (w4 :: [(GHC.Types.Int, Language.Expression)])
                            (w5 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                          case w4 of wild3 {
                            [] -> (# w5, GHC.Types.[] @ (GHC.Types.Int, Language.Expression) #)
                            : ds3 rest1
                            -> case ds3 of wild4 { (,) lno1 e1 ->
                               case GHC.Prim.readMutVar#
                                      @ GHC.Prim.RealWorld
                                      @ [Modules.Module]
                                      var#
                                      w5 of ds4 { (#,#) ipv2 ipv3 ->
                               let {
                                 ds5 :: (GHC.Types.Int, [Language.Expression])
                                 = case Transform.$waddTemporaries1
                                          ipv3
                                          w3
                                          e1 of ww { (#,#) ww1 ww2 ->
                                   (ww1, ww2) }
                               } in
                               case $waddTemporaries'
                                      (case ds5 of wild5 { (,) next' es -> next' })
                                      rest1
                                      ipv2 of ds6 { (#,#) ipv4 ipv5 ->
                               (# ipv4,
                                  case ds5 of wild5 { (,) next' es ->
                                  letrec {
                                    go :: [Language.Expression]
                                          -> [(GHC.Types.Int, Language.Expression)]
                                      {- Arity: 1, Strictness: <S,1*U> -}
                                    = \ (ds7 :: [Language.Expression]) ->
                                      case ds7 of wild6 {
                                        [] -> ipv5
                                        : y ys
                                        -> GHC.Types.:
                                             @ (GHC.Types.Int, Language.Expression)
                                             (lno1, y)
                                             (go ys) }
                                  } in
                                  go es } #) } } } }
                      } in
                      case $waddTemporaries'
                             (case ds2 of wild3 { (,) next' es -> next' })
                             rest
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      (# ipv2,
                         case ds2 of wild3 { (,) next' es ->
                         letrec {
                           go :: [Language.Expression]
                                 -> [(GHC.Types.Int, Language.Expression)]
                             {- Arity: 1, Strictness: <S,1*U> -}
                           = \ (ds4 :: [Language.Expression]) ->
                             case ds4 of wild4 {
                               [] -> ipv3
                               : y ys
                               -> GHC.Types.:
                                    @ (GHC.Types.Int, Language.Expression)
                                    (lno, y)
                                    (go ys) }
                         } in
                         go es } #) } } } } }) -}
e4189a7e3b25a0141577cfb29bed5212
  transform2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f8c05f608c0f171685db13f812ae9a25
  transform3 ::
    [(GHC.Types.Int, Language.Expression)]
    -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 3, Strictness: <S,1*U><L,A><S,U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [(GHC.Types.Int, Language.Expression)])
                   (w1 :: GHC.IORef.IORef
                            Control.Monad.Trans.Resource.Internal.ReleaseMap)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 Transform.$waddOutputHash w w2) -}
b1e4f6666557bb57c3829e4131480465
  transform4 :: Language.Expression -> Language.Expression
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Expression) ->
                 case ds of wild {
                   DEFAULT -> wild
                   Language.Condition ds1 ds2 ds3
                   -> case ds1 of wild1 {
                        DEFAULT -> wild
                        Language.BinaryOp b ds4 ds5
                        -> case ds4 of wild2 {
                             DEFAULT -> wild
                             Language.UnaryOp ds6 ds7
                             -> case ds6 of wild3 {
                                  DEFAULT -> wild
                                  Language.UOpLen
                                  -> case ds7 of wild4 {
                                       DEFAULT -> wild
                                       Language.Lookup ds8 v
                                       -> case ds5 of wild5 {
                                            DEFAULT -> wild
                                            Language.ConstInt thresh
                                            -> case ds2 of wild6 {
                                                 DEFAULT -> wild
                                                 Language.Sequence ds9
                                                 -> case ds9 of wild7 {
                                                      [] -> wild
                                                      : ds10 ds11
                                                      -> case ds10 of wild8 {
                                                           DEFAULT -> wild
                                                           Language.Discard
                                                           -> case ds11 of wild9 {
                                                                []
                                                                -> case ds3 of wild10 {
                                                                     DEFAULT -> wild
                                                                     Language.Sequence ds12
                                                                     -> case ds12 of wild11 {
                                                                          []
                                                                          -> case GHC.List.elem
                                                                                    @ Language.BOp
                                                                                    Language.$fEqBOp
                                                                                    b
                                                                                    (GHC.Types.:
                                                                                       @ Language.BOp
                                                                                       Language.BOpLT
                                                                                       (GHC.Types.:
                                                                                          @ Language.BOp
                                                                                          Language.BOpLTE
                                                                                          (GHC.Types.:
                                                                                             @ Language.BOp
                                                                                             Language.BOpGT
                                                                                             (GHC.Types.:
                                                                                                @ Language.BOp
                                                                                                Language.BOpGTE
                                                                                                (GHC.Types.[]
                                                                                                   @ Language.BOp))))) of wild12 {
                                                                               GHC.Types.False
                                                                               -> wild
                                                                               GHC.Types.True
                                                                               -> Language.Optimized
                                                                                    (Language.LenThresholdDiscard
                                                                                       v
                                                                                       b
                                                                                       (GHC.Num.$fNumInt_$cfromInteger
                                                                                          thresh)) }
                                                                          : ipv ipv1 -> wild } }
                                                                : ipv ipv1
                                                                -> wild } } } } } } } } } }) -}
7b4997fd0d0590ae90c14096df3ed39b
  transform5 :: Language.Expression -> Language.Expression
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Language.Expression) ->
                 case ds of wild {
                   DEFAULT -> wild
                   Language.Assignment v ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> wild
                        Language.FunctionCall ds2 ds3 ds4 ds5
                        -> case ds2
                                  `cast`
                                (Language.N:FuncName[0]) of wild2 { Data.Text.Internal.Text dt dt1 dt2 ->
                           case Data.Text.Show.unpackCString#
                                  "substrim"# of wild3 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                           case GHC.Prim.==# dt2 dt5 of lwild {
                             DEFAULT -> wild
                             1#
                             -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                               -> GHC.Prim.Word#
                                                               -> GHC.Prim.ByteArray#
                                                               -> GHC.Prim.Word#
                                                               -> GHC.Prim.Word#
                                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Int# #)}
                                       dt
                                       (GHC.Prim.int2Word# dt1)
                                       dt3
                                       (GHC.Prim.int2Word# dt4)
                                       (GHC.Prim.int2Word# dt2)
                                       GHC.Prim.realWorld# of wild5 { (#,#) ds6 ds7 ->
                                case GHC.Prim.narrow32Int# ds7 of wild4 {
                                  DEFAULT -> wild
                                  0#
                                  -> case ds3 of wild6 {
                                       DEFAULT -> wild
                                       Language.Lookup ds8 v'
                                       -> case ds4 of wild7 {
                                            [] -> wild
                                            : ds9 ds10
                                            -> case ds9 of wild8 { (,) ds11 ds12 ->
                                               case ds11
                                                      `cast`
                                                    (Language.N:Variable[0]) of wild9 { Data.Text.Internal.Text dt7 dt8 dt9 ->
                                               case Data.Text.Show.unpackCString#
                                                      "min_quality"# of wild10 { Data.Text.Internal.Text dt10 dt11 dt12 ->
                                               case GHC.Prim.==# dt9 dt12 of lwild1 {
                                                 DEFAULT -> wild
                                                 1#
                                                 -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.ByteArray#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.State#
                                                                                        GHC.Prim.RealWorld
                                                                                   -> (# GHC.Prim.State#
                                                                                           GHC.Prim.RealWorld,
                                                                                         GHC.Prim.Int# #)}
                                                           dt7
                                                           (GHC.Prim.int2Word# dt8)
                                                           dt10
                                                           (GHC.Prim.int2Word# dt11)
                                                           (GHC.Prim.int2Word# dt9)
                                                           GHC.Prim.realWorld# of wild11 { (#,#) ds13 ds14 ->
                                                    case GHC.Prim.narrow32Int# ds14 of wild12 {
                                                      DEFAULT -> wild
                                                      0#
                                                      -> case ds12 of wild13 {
                                                           DEFAULT -> wild
                                                           Language.ConstInt mq
                                                           -> case ds10 of wild14 {
                                                                []
                                                                -> case ds5 of wild15 {
                                                                     GHC.Maybe.Nothing
                                                                     -> case v `cast`
                                                                             (Language.N:Variable[0]) of wild16 { Data.Text.Internal.Text dt13 dt14 dt15 ->
                                                                        case v'
                                                                               `cast`
                                                                             (Language.N:Variable[0]) of wild17 { Data.Text.Internal.Text dt16 dt17 dt18 ->
                                                                        case GHC.Prim.==#
                                                                               dt15
                                                                               dt18 of lwild2 {
                                                                          DEFAULT -> wild
                                                                          1#
                                                                          -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                                                                            -> GHC.Prim.Word#
                                                                                                            -> GHC.Prim.ByteArray#
                                                                                                            -> GHC.Prim.Word#
                                                                                                            -> GHC.Prim.Word#
                                                                                                            -> GHC.Prim.State#
                                                                                                                 GHC.Prim.RealWorld
                                                                                                            -> (# GHC.Prim.State#
                                                                                                                    GHC.Prim.RealWorld,
                                                                                                                  GHC.Prim.Int# #)}
                                                                                    dt13
                                                                                    (GHC.Prim.int2Word#
                                                                                       dt14)
                                                                                    dt16
                                                                                    (GHC.Prim.int2Word#
                                                                                       dt17)
                                                                                    (GHC.Prim.int2Word#
                                                                                       dt15)
                                                                                    GHC.Prim.realWorld# of wild18 { (#,#) ds15 ds16 ->
                                                                             case GHC.Prim.narrow32Int#
                                                                                    ds16 of wild19 {
                                                                               DEFAULT -> wild
                                                                               0#
                                                                               -> Language.Optimized
                                                                                    (Language.SubstrimReassign
                                                                                       wild16
                                                                                         `cast`
                                                                                       (Sym (Language.N:Variable[0]))
                                                                                       (GHC.Num.$fNumInt_$cfromInteger
                                                                                          mq)) } } } } }
                                                                     GHC.Maybe.Just ipv -> wild }
                                                                : ipv ipv1
                                                                -> wild } } } } } } } } } } } } } } } } }) -}
1ecb70fbba3fe9dcf23ee3a79a97de8a
  transform6 ::
    [(GHC.Types.Int, Language.Expression)]
    -> GHC.IORef.IORef Control.Monad.Trans.Resource.Internal.ReleaseMap
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(GHC.Types.Int, Language.Expression)] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U> -}
7ed11b1b842622b1fb9b72ceda1d8cfe
  transform_$sgenericCheckUpfloat' ::
    [(GHC.Types.Int, Language.Expression)]
    -> [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <S,1*U> -}
f9aa56987baa8b99e8add0a45e7e35a9
  transform_$sgenericCheckUpfloat'1 ::
    [(GHC.Types.Int, Language.Expression)]
    -> [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <S,1*U> -}
9cf049a29d776df222a2dff276ae1c26
  transform_writeToMove' ::
    [Language.Variable]
    -> [(GHC.Types.Int, Language.Expression)]
    -> [(GHC.Types.Int, Language.Expression)]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
f4e8b5b8c678a0ef9cffd2225ee05cbb
  writeToMove ::
    [(GHC.Types.Int, Language.Expression)]
    -> NGLess.NGError.NGLessIO [(GHC.Types.Int, Language.Expression)]
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [(GHC.Types.Int, Language.Expression)]) ->
                 let {
                   eta :: [(GHC.Types.Int, Language.Expression)]
                   = Transform.transform_writeToMove'
                       (GHC.Types.[] @ Language.Variable)
                       x
                 } in
                 (\ (eta1 :: GHC.IORef.IORef
                               Control.Monad.Trans.Resource.Internal.ReleaseMap)
                    (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                  (# eta2, eta #))
                   `cast`
                 ((<GHC.IORef.IORef
                      Control.Monad.Trans.Resource.Internal.ReleaseMap>_R
                   ->_R Sym (GHC.Types.N:IO[0]
                                 <[(GHC.Types.Int,
                                    Language.Expression)]>_R)) ; (Sym (Control.Monad.Trans.Resource.Internal.N:ResourceT[0]
                                                                           <GHC.Types.IO>_R
                                                                           <[(GHC.Types.Int,
                                                                              Language.Expression)]>_N) ; Sym (NGLess.NGError.N:NGLessIO[0]) <[(GHC.Types.Int,
                                                                                                                                                Language.Expression)]>_N))) -}
"SPEC/Transform $fApplicativeRWST @ [Expression] @ Identity _ _" [orphan] forall @ r
                                                                                 @ s
                                                                                 (v2 :: GHC.Base.Monad
                                                                                          Data.Functor.Identity.Identity)
                                                                                 (v1 :: GHC.Base.Functor
                                                                                          Data.Functor.Identity.Identity)
                                                                                 (v :: GHC.Base.Monoid
                                                                                         [Language.Expression])
  Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST @ [Language.Expression]
                                                 @ Data.Functor.Identity.Identity
                                                 @ r
                                                 @ s
                                                 v
                                                 v1
                                                 v2
  = Transform.$s$fApplicativeRWST @ r @ s
"SPEC/Transform $fApplicativeRWST_$c<*> @ [Expression] @ Identity _ _" [orphan] forall @ r
                                                                                       @ s
                                                                                       ($dMonad :: GHC.Base.Monad
                                                                                                     Data.Functor.Identity.Identity)
                                                                                       ($dFunctor :: GHC.Base.Functor
                                                                                                       Data.Functor.Identity.Identity)
                                                                                       ($dMonoid :: GHC.Base.Monoid
                                                                                                      [Language.Expression])
  Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST_$c<*> @ [Language.Expression]
                                                       @ Data.Functor.Identity.Identity
                                                       @ r
                                                       @ s
                                                       $dMonoid
                                                       $dFunctor
                                                       $dMonad
  = Transform.$s$fApplicativeRWST_$s$fApplicativeRWST_$c<*> @ r @ s
"SPEC/Transform $fApplicativeRWST_$cpure @ [Expression] @ Identity _ _" [orphan] forall @ r
                                                                                        @ s
                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                      Data.Functor.Identity.Identity)
                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                        Data.Functor.Identity.Identity)
                                                                                        ($dMonoid :: GHC.Base.Monoid
                                                                                                       [Language.Expression])
  Control.Monad.Trans.RWS.Lazy.$fApplicativeRWST_$cpure @ [Language.Expression]
                                                        @ Data.Functor.Identity.Identity
                                                        @ r
                                                        @ s
                                                        $dMonoid
                                                        $dFunctor
                                                        $dMonad
  = Transform.$s$fApplicativeRWST_$s$fApplicativeRWST_$cpure @ r @ s
"SPEC/Transform $fApplicativeStateT @ Identity _" [orphan] forall @ s
                                                                  (v1 :: GHC.Base.Monad
                                                                           Data.Functor.Identity.Identity)
                                                                  (v :: GHC.Base.Functor
                                                                          Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ Data.Functor.Identity.Identity
                                                     @ s
                                                     v
                                                     v1
  = Transform.$s$fApplicativeStateT @ s
"SPEC/Transform $fApplicativeStateT_$c*> @ Identity _" [orphan] forall @ s
                                                                       ($dMonad :: GHC.Base.Monad
                                                                                     Data.Functor.Identity.Identity)
                                                                       ($dFunctor :: GHC.Base.Functor
                                                                                       Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*> @ Data.Functor.Identity.Identity
                                                          @ s
                                                          $dFunctor
                                                          $dMonad
  = Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*> @ s
"SPEC/Transform $fApplicativeStateT_$c<*> @ Identity _" [orphan] forall @ s
                                                                        ($dMonad :: GHC.Base.Monad
                                                                                      Data.Functor.Identity.Identity)
                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                        Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ Data.Functor.Identity.Identity
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s
"SPEC/Transform $fApplicativeStateT_$cpure @ Identity _" [orphan] forall @ s
                                                                         ($dMonad :: GHC.Base.Monad
                                                                                       Data.Functor.Identity.Identity)
                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                         Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ Data.Functor.Identity.Identity
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Transform.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s
"SPEC/Transform $fApplicativeWriterT @ [(Variable,
                                        Expression)] @ (Either NGError)" [orphan] forall (v1 :: GHC.Base.Applicative
                                                                                                                                                     (Data.Either.Either
                                                                                                                                                        NGLess.NGError.NGError))
                                                                                                                                            (v :: GHC.Base.Monoid
                                                                                                                                                    [(Language.Variable,
                                                                                                                                                      Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT @ [(Language.Variable,
                                                           Language.Expression)]
                                                       @ (Data.Either.Either NGLess.NGError.NGError)
                                                       v
                                                       v1
  = Transform.$s$fApplicativeWriterT
"SPEC/Transform $fApplicativeWriterT @ [(Variable,
                                        Expression)] @ Identity" [orphan] forall (v1 :: GHC.Base.Applicative
                                                                                                                                             Data.Functor.Identity.Identity)
                                                                                                                                    (v :: GHC.Base.Monoid
                                                                                                                                            [(Language.Variable,
                                                                                                                                              Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT @ [(Language.Variable,
                                                           Language.Expression)]
                                                       @ Data.Functor.Identity.Identity
                                                       v
                                                       v1
  = Transform.$s$fApplicativeWriterT2
"SPEC/Transform $fApplicativeWriterT @ [Variable] @ Identity" [orphan] forall (v1 :: GHC.Base.Applicative
                                                                                       Data.Functor.Identity.Identity)
                                                                              (v :: GHC.Base.Monoid
                                                                                      [Language.Variable])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT @ [Language.Variable]
                                                       @ Data.Functor.Identity.Identity
                                                       v
                                                       v1
  = Transform.$s$fApplicativeWriterT1
"SPEC/Transform $fApplicativeWriterT2 @ [(Variable,
                                         Expression)] @ (Either NGError)" [orphan] [2] forall (w2 :: GHC.Base.Applicative
                                                                                                                                                           (Data.Either.Either
                                                                                                                                                              NGLess.NGError.NGError))
                                                                                                                                                  (w1 :: GHC.Base.Monoid
                                                                                                                                                           [(Language.Variable,
                                                                                                                                                             Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT2 @ [(Language.Variable,
                                                            Language.Expression)]
                                                        @ (Data.Either.Either
                                                             NGLess.NGError.NGError)
                                                        w1
                                                        w2
  = Transform.$s$fApplicativeWriterT3
"SPEC/Transform $fApplicativeWriterT_$c<* @ [(Variable,
                                             Expression)] @ (Either NGError)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                          (Data.Either.Either
                                                                                                                                                                             NGLess.NGError.NGError))
                                                                                                                                                      ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                     [(Language.Variable,
                                                                                                                                                                       Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<* @ [(Language.Variable,
                                                                Language.Expression)]
                                                            @ (Data.Either.Either
                                                                 NGLess.NGError.NGError)
                                                            $dMonoid
                                                            $dApplicative
  = Transform.$s$fApplicativeWriterT_$c<*
"SPEC/Transform $fApplicativeWriterT_$c<* @ [(Variable,
                                             Expression)] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                  Data.Functor.Identity.Identity)
                                                                                                                                              ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                             [(Language.Variable,
                                                                                                                                                               Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<* @ [(Language.Variable,
                                                                Language.Expression)]
                                                            @ Data.Functor.Identity.Identity
                                                            $dMonoid
                                                            $dApplicative
  = Transform.$s$fApplicativeWriterT_$c<*2
"SPEC/Transform $fApplicativeWriterT_$c<* @ [Variable] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                       Data.Functor.Identity.Identity)
                                                                                   ($dMonoid :: GHC.Base.Monoid
                                                                                                  [Language.Variable])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<* @ [Language.Variable]
                                                            @ Data.Functor.Identity.Identity
                                                            $dMonoid
                                                            $dApplicative
  = Transform.$s$fApplicativeWriterT_$c<*1
"SPEC/Transform $fApplicativeWriterT_$c<*> @ [(Variable,
                                              Expression)] @ (Either NGError)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                            (Data.Either.Either
                                                                                                                                                                               NGLess.NGError.NGError))
                                                                                                                                                        ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                       [(Language.Variable,
                                                                                                                                                                         Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<*> @ [(Language.Variable,
                                                                 Language.Expression)]
                                                             @ (Data.Either.Either
                                                                  NGLess.NGError.NGError)
                                                             $dMonoid
                                                             $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>
"SPEC/Transform $fApplicativeWriterT_$c<*> @ [(Variable,
                                              Expression)] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                    Data.Functor.Identity.Identity)
                                                                                                                                                ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                               [(Language.Variable,
                                                                                                                                                                 Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<*> @ [(Language.Variable,
                                                                 Language.Expression)]
                                                             @ Data.Functor.Identity.Identity
                                                             $dMonoid
                                                             $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>2
"SPEC/Transform $fApplicativeWriterT_$c<*> @ [Variable] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                        Data.Functor.Identity.Identity)
                                                                                    ($dMonoid :: GHC.Base.Monoid
                                                                                                   [Language.Variable])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$c<*> @ [Language.Variable]
                                                             @ Data.Functor.Identity.Identity
                                                             $dMonoid
                                                             $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$c<*>1
"SPEC/Transform $fApplicativeWriterT_$cpure @ [(Variable,
                                               Expression)] @ (Either NGError)" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                              (Data.Either.Either
                                                                                                                                                                                 NGLess.NGError.NGError))
                                                                                                                                                          ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                         [(Language.Variable,
                                                                                                                                                                           Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cpure @ [(Language.Variable,
                                                                  Language.Expression)]
                                                              @ (Data.Either.Either
                                                                   NGLess.NGError.NGError)
                                                              $dMonoid
                                                              $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure
"SPEC/Transform $fApplicativeWriterT_$cpure @ [(Variable,
                                               Expression)] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                      Data.Functor.Identity.Identity)
                                                                                                                                                  ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                                 [(Language.Variable,
                                                                                                                                                                   Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cpure @ [(Language.Variable,
                                                                  Language.Expression)]
                                                              @ Data.Functor.Identity.Identity
                                                              $dMonoid
                                                              $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure2
"SPEC/Transform $fApplicativeWriterT_$cpure @ [Variable] @ Identity" [orphan] forall ($dApplicative :: GHC.Base.Applicative
                                                                                                         Data.Functor.Identity.Identity)
                                                                                     ($dMonoid :: GHC.Base.Monoid
                                                                                                    [Language.Variable])
  Control.Monad.Trans.Writer.Lazy.$fApplicativeWriterT_$cpure @ [Language.Variable]
                                                              @ Data.Functor.Identity.Identity
                                                              $dMonoid
                                                              $dApplicative
  = Transform.$s$fApplicativeWriterT_$s$fApplicativeWriterT_$cpure1
"SPEC/Transform $fFunctorRWST @ Identity _ _ _" [orphan] forall @ r
                                                                @ w
                                                                @ s
                                                                (v :: GHC.Base.Functor
                                                                        Data.Functor.Identity.Identity)
  Control.Monad.Trans.RWS.Lazy.$fFunctorRWST @ Data.Functor.Identity.Identity
                                             @ r
                                             @ w
                                             @ s
                                             v
  = Transform.$s$fApplicativeRWST_$s$fFunctorRWST @ r @ w @ s
"SPEC/Transform $fFunctorStateT @ Identity _" [orphan] forall @ s
                                                              (v :: GHC.Base.Functor
                                                                      Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ Data.Functor.Identity.Identity
                                                 @ s
                                                 v
  = Transform.$s$fApplicativeStateT_$s$fFunctorStateT @ s
"SPEC/Transform $fFunctorWriterT @ (Either NGError) _" [orphan] forall @ w
                                                                       (v :: GHC.Base.Functor
                                                                               (Data.Either.Either
                                                                                  NGLess.NGError.NGError))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT @ (Data.Either.Either
                                                        NGLess.NGError.NGError)
                                                   @ w
                                                   v
  = Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT @ w
"SPEC/Transform $fFunctorWriterT @ Identity _" [orphan] forall @ w
                                                               (v :: GHC.Base.Functor
                                                                       Data.Functor.Identity.Identity)
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT @ Data.Functor.Identity.Identity
                                                   @ w
                                                   v
  = Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT1 @ w
"SPEC/Transform $fFunctorWriterT_$c<$ @ (Either NGError) _" [orphan] forall @ w
                                                                            ($dFunctor :: GHC.Base.Functor
                                                                                            (Data.Either.Either
                                                                                               NGLess.NGError.NGError))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$c<$ @ (Data.Either.Either
                                                             NGLess.NGError.NGError)
                                                        @ w
                                                        $dFunctor
  = Transform.$s$fFunctorWriterT_$c<$ @ w
"SPEC/Transform $fFunctorWriterT_$cfmap @ (Either NGError) _" [orphan] forall @ w
                                                                              ($dFunctor :: GHC.Base.Functor
                                                                                              (Data.Either.Either
                                                                                                 NGLess.NGError.NGError))
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$cfmap @ (Data.Either.Either
                                                               NGLess.NGError.NGError)
                                                          @ w
                                                          $dFunctor
  = Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap @ w
"SPEC/Transform $fFunctorWriterT_$cfmap @ Identity _" [orphan] forall @ w
                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                      Data.Functor.Identity.Identity)
  Control.Monad.Trans.Writer.Lazy.$fFunctorWriterT_$cfmap @ Data.Functor.Identity.Identity
                                                          @ w
                                                          $dFunctor
  = Transform.$s$fApplicativeWriterT_$s$fFunctorWriterT_$cfmap1 @ w
"SPEC/Transform $fMonadRWST_$c>>= @ [Expression] @ Identity _ _" [orphan] forall @ r
                                                                                 @ s
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               Data.Functor.Identity.Identity)
                                                                                 ($dMonoid :: GHC.Base.Monoid
                                                                                                [Language.Expression])
  Control.Monad.Trans.RWS.Lazy.$fMonadRWST_$c>>= @ [Language.Expression]
                                                 @ Data.Functor.Identity.Identity
                                                 @ r
                                                 @ s
                                                 $dMonoid
                                                 $dMonad
  = Transform.$s$fMonadRWST_$s$fMonadRWST_$c>>= @ r @ s
"SPEC/Transform $fMonadStateT_$c>>= @ Identity _" [orphan] forall @ s
                                                                  ($dMonad :: GHC.Base.Monad
                                                                                Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ Data.Functor.Identity.Identity
                                                     @ s
                                                     $dMonad
  = Transform.$s$fMonadStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/Transform $fMonadWriterT_$c>> @ [(Variable,
                                       Expression)] @ (Either NGError)" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                        (Data.Either.Either
                                                                                                                                                           NGLess.NGError.NGError))
                                                                                                                                          ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                         [(Language.Variable,
                                                                                                                                                           Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>> @ [(Language.Variable,
                                                          Language.Expression)]
                                                      @ (Data.Either.Either NGLess.NGError.NGError)
                                                      $dMonoid
                                                      $dMonad
  = Transform.$s$fMonadWriterT_$s$fMonadWriterT_$c>>
"SPEC/Transform $fMonadWriterT_$c>> @ [(Variable,
                                       Expression)] @ Identity" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                                                                                Data.Functor.Identity.Identity)
                                                                                                                                  ($dMonoid :: GHC.Base.Monoid
                                                                                                                                                 [(Language.Variable,
                                                                                                                                                   Language.Expression)])
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>> @ [(Language.Variable,
                                                          Language.Expression)]
                                                      @ Data.Functor.Identity.Identity
                                                      $dMonoid
                                                      $dMonad
  = Transform.$s$fMonadWriterT_$s$fMonadWriterT_$c>>2
"SPEC/Transform $fMonadWriterT_$c>> @ [Variable] @ Identity" [orphan] forall ($dMonad :: GHC.Base.Monad
                                                                                           Data.Functor.Identity.Identity)
                                                                             ($dMonoid :: GHC.Base.Monoid
                                                                                            [Language.Variable])
  Control.Monad.Trans.Writer.Lazy.$fMonadWriterT_$c>> @ [Language.Variable]
                                                      @ Data.Functor.Identity.Identity
                                                      $dMonoid
                                                      $dMonad
  = Transform.$s$fMonadWriterT_$s$fMonadWriterT_$c>>1
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

