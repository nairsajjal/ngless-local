
==================== FINAL INTERFACE ====================
2020-02-24 04:14:35.613664515 UTC

interface NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5:Utils.Utils 8065
  interface hash: 983605e74d6d8da623953fc62dde6f86
  ABI hash: 5a5b516d92cb4d06150e4c1e7f1bff1d
  export-list hash: c13ae65e393f7bcdefbb619c4fc6a77b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 3760c889d7f7ac4be0e3af4058bfdc33
  opt_hash: 9851e58a0ec35d0fd39c07cdbeb6257b
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.Utils.allSame
  Utils.Utils.dropEnd
  Utils.Utils.findM
  Utils.Utils.fmapMaybeM
  Utils.Utils.lookupWithDefault
  Utils.Utils.mapMaybeM
  Utils.Utils.maybeM
  Utils.Utils.moveOrCopy
  Utils.Utils.passthrough
  Utils.Utils.secondM
  Utils.Utils.uniq
  System.IO.SafeWrite.withOutputFile
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0* deepseq-1.4.4.0
                      directory-1.3.3.0 exceptions-0.10.4 filepath-1.4.2.1
                      ghc-boot-th-8.6.5 ghc-prim-0.5.3 integer-gmp-1.0.2.0 mtl-2.2.2
                      safeio-0.0.5.0 stm-2.5.0.0 template-haskell-2.14.0.0 time-1.8.0.2
                      transformers-0.5.6.2 unix-2.7.2.2
orphans: stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.6.2:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
import  -/  base-4.12.0.0:Control.Exception 041da5b6267cf6b639ff5716d5b299a9
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:Data.Traversable d2c09bff1e4f0c871306c3ff8aa4dc36
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.IO 898d4ddbf00eb4732e5f462760aa42ae
import  -/  base-4.12.0.0:GHC.IO.Exception 77722984940ee6ccf9e2f7dab10b83a4
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:System.IO.Error 4554cd72d03d7e89c9020f2d00a768a1
import  -/  directory-1.3.3.0:System.Directory 79b5722ff1e84b2378a22f8587a77df6
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  safeio-0.0.5.0:System.IO.SafeWrite d7756aa6dd46103e1e3f96abe2c18fe3
addDependentFile "/home/sajjal/.stack/programs/x86_64-linux/ghc-8.6.5/lib/ghc-8.6.5/include/ghcversion.h" 43db44f9bb88490c2fa995e5f5ec33f2
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-2.4.0.1/build/autogen/cabal_macros.h" e3731cb12b83b9e47defd67255252b42
addDependentFile "/usr/include/stdc-predef.h" 64086a4476ea583071277345b423d741
7d48f768b730be8bf2bcf903f37413db
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Utils.Utils.$trModule3
                   Utils.Utils.$trModule1) -}
2f57c0884dfec6b56d81744593da9f2c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Utils.$trModule2) -}
02ed1f60ebd105d28ced6e5106feb359
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils.Utils"#) -}
ae3e65a1119f325ffff19191233f341c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Utils.$trModule4) -}
7089c74588eaa460f088eaabe1390452
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5"#) -}
9e2aff70d99d01a6e96f2fd2755240e9
  $wfindM ::
    (forall a1 b1. m a1 -> (a1 -> m b1) -> m b1)
    -> (forall a1. a1 -> m a1)
    -> [a]
    -> (a -> m (GHC.Maybe.Maybe b))
    -> m (GHC.Maybe.Maybe b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,C(U)><S,1*U><L,C(U)>, Inline: [2] -}
104810d5b15a6c6840bbf8d8c581871a
  $wfmapMaybeM ::
    GHC.Base.Applicative m =>
    (forall a1. a1 -> m a1)
    -> (a -> m b) -> GHC.Maybe.Maybe a -> m (GHC.Maybe.Maybe b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A)><L,1*C1(U)><L,1*C1(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ b
                   (ww :: GHC.Base.Applicative m)
                   (ww1 :: forall a1. a1 -> m a1)
                   (w :: a -> m b)
                   (w1 :: GHC.Maybe.Maybe a) ->
                 case w1 of wild {
                   GHC.Maybe.Nothing
                   -> ww1 @ (GHC.Maybe.Maybe b) (GHC.Maybe.Nothing @ b)
                   GHC.Maybe.Just v
                   -> GHC.Base.fmap
                        @ m
                        (GHC.Base.$p1Applicative @ m ww)
                        @ b
                        @ (GHC.Maybe.Maybe b)
                        (GHC.Maybe.Just @ b)
                        (w v) }) -}
b1fb53ddc578dbdc56cba5ec41b24366
  $wmapMaybeM ::
    (forall a1 b1. (a1 -> b1) -> m a1 -> m b1)
    -> (forall a1. a1 -> m a1)
    -> (forall a1 b1 c. (a1 -> b1 -> c) -> m a1 -> m b1 -> m c)
    -> (a -> m (GHC.Maybe.Maybe b))
    -> [a]
    -> m [b]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,1*C1(U)><L,C(C1(C1(U)))><L,C(U)><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ b
                   (ww :: forall a1 b1. (a1 -> b1) -> m a1 -> m b1)
                   (ww1 :: forall a1. a1 -> m a1)
                   (ww2 :: forall a1 b1 c. (a1 -> b1 -> c) -> m a1 -> m b1 -> m c)
                   (w :: a -> m (GHC.Maybe.Maybe b))
                   (w1 :: [a]) ->
                 ww
                   @ [GHC.Maybe.Maybe b]
                   @ [b]
                   (Data.Maybe.catMaybes @ b)
                   (let {
                      z :: m [GHC.Maybe.Maybe b]
                      = ww1 @ [GHC.Maybe.Maybe b] (GHC.Types.[] @ (GHC.Maybe.Maybe b))
                    } in
                    letrec {
                      go :: [a] -> m [GHC.Maybe.Maybe b]
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [a]) ->
                        case ds of wild {
                          [] -> z
                          : y ys
                          -> ww2
                               @ (GHC.Maybe.Maybe b)
                               @ [GHC.Maybe.Maybe b]
                               @ [GHC.Maybe.Maybe b]
                               (GHC.Types.: @ (GHC.Maybe.Maybe b))
                               (w y)
                               (go ys) }
                    } in
                    go w1)) -}
2721994df9650ea2f567bdf4548262e2
  $wmaybeM ::
    (forall a1 b1. m a1 -> (a1 -> m b1) -> m b1)
    -> (forall a1. a1 -> m a1)
    -> m (GHC.Maybe.Maybe a)
    -> (a -> m (GHC.Maybe.Maybe b))
    -> m (GHC.Maybe.Maybe b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,C(U)><L,U><L,C(U)>,
     Inline: [2],
     Unfolding: (\ @ m :: * -> *
                   @ a
                   @ b
                   (ww :: forall a1 b1. m a1 -> (a1 -> m b1) -> m b1)
                   (ww1 :: forall a1. a1 -> m a1)
                   (w :: m (GHC.Maybe.Maybe a))
                   (w1 :: a -> m (GHC.Maybe.Maybe b)) ->
                 ww
                   @ (GHC.Maybe.Maybe a)
                   @ (GHC.Maybe.Maybe b)
                   w
                   (\ (ds :: GHC.Maybe.Maybe a) ->
                    case ds of wild {
                      GHC.Maybe.Nothing
                      -> ww1 @ (GHC.Maybe.Maybe b) (GHC.Maybe.Nothing @ b)
                      GHC.Maybe.Just a1 -> w1 a1 })) -}
40cad5086287ca763e1d068d1ee83fb8
  allSame :: GHC.Classes.Eq a => [a] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (ds :: [a]) ->
                 case ds of wild {
                   [] -> GHC.Types.True
                   : e es
                   -> (GHC.Base.foldr
                         @ a
                         @ Data.Semigroup.Internal.All
                         (\ (x :: a) (x1 :: GHC.Types.Bool)[OneShot] ->
                          case GHC.Classes.== @ a $dEq x e of wild1 {
                            GHC.Types.False -> GHC.Types.False GHC.Types.True -> x1 })
                           `cast`
                         (<a>_R
                          ->_R Sym (Data.Semigroup.Internal.N:All[0])
                          ->_R Sym (Data.Semigroup.Internal.N:All[0]))
                         GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                         es)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) }) -}
f778e9955686f8a9fddc83cd57ef5a29
  dropEnd :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a (v :: GHC.Types.Int) (a1 :: [a]) ->
                 let {
                   n :: GHC.Types.Int
                   = case GHC.Base.foldr
                            @ a
                            @ (GHC.Types.Int -> GHC.Types.Int)
                            (GHC.List.lengthFB @ a)
                            GHC.List.idLength
                            a1
                            (GHC.Types.I# 0#) of wild { GHC.Types.I# x ->
                     case v of wild1 { GHC.Types.I# y ->
                     GHC.Types.I# (GHC.Prim.-# x y) } }
                 } in
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (nil :: b)[OneShot] ->
                    case GHC.Classes.ltInt (GHC.Types.I# 0#) n of wild {
                      GHC.Types.False -> nil
                      GHC.Types.True
                      -> GHC.Base.foldr
                           @ a
                           @ (GHC.Types.Int -> b)
                           (GHC.List.takeFB @ a @ b c nil)
                           (GHC.List.flipSeqTake @ b nil)
                           a1
                           n })) -}
e185b35b313a7e6a9650a8a1af507634
  findM ::
    GHC.Base.Monad m =>
    [a] -> (a -> m (GHC.Maybe.Maybe b)) -> m (GHC.Maybe.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(A,C(C1(U)),A,C(U),A)><S,1*U><L,C(U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: [a])
                   (w2 :: a -> m (GHC.Maybe.Maybe b)) ->
                 case w of ww { GHC.Base.C:Monad ww1 ww2 ww3 ww4 ww5 ->
                 Utils.Utils.$wfindM @ m @ a @ b ww2 ww4 w1 w2 }) -}
e3eabcea0ea26c7883f4bc280e31f2a9
  fmapMaybeM ::
    GHC.Base.Monad m =>
    (a -> m b) -> GHC.Maybe.Maybe a -> m (GHC.Maybe.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,1*C1(U),A)><L,1*C1(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: a -> m b)
                   (w2 :: GHC.Maybe.Maybe a) ->
                 case w of ww { GHC.Base.C:Monad ww1 ww2 ww3 ww4 ww5 ->
                 Utils.Utils.$wfmapMaybeM @ m @ a @ b ww1 ww4 w1 w2 }) -}
f726e411eb6f1bf89e701bdb29616abc
  lookupWithDefault :: GHC.Classes.Eq b => a -> b -> [(b, a)] -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,1*U><L,U><S,1*U>,
     Inline: (sat-args=3),
     Unfolding: InlineRule (4, False, False)
                (\ @ b
                   @ a
                   ($dEq :: GHC.Classes.Eq b)
                   (def :: a)
                   (key :: b)
                   (values :: [(b, a)]) ->
                 case GHC.List.lookup @ b @ a $dEq key values of wild {
                   GHC.Maybe.Nothing -> def GHC.Maybe.Just v -> v }) -}
cc9488cea6752045089aba9c53d05946
  mapMaybeM ::
    GHC.Base.Monad m => (a -> m (GHC.Maybe.Maybe b)) -> [a] -> m [b]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: a -> m (GHC.Maybe.Maybe b))
                   (w2 :: [a]) ->
                 case w of ww { GHC.Base.C:Monad ww1 ww2 ww3 ww4 ww5 ->
                 case ww1 of ww6 { GHC.Base.C:Applicative ww7 ww8 ww9 ww10 ww11 ww12 ->
                 case ww7 of ww13 { GHC.Base.C:Functor ww14 ww15 ->
                 Utils.Utils.$wmapMaybeM @ m @ a @ b ww14 ww8 ww10 w1 w2 } } }) -}
4700e199879cb7e85c118b6e6ff84ad0
  maybeM ::
    GHC.Base.Monad m =>
    m (GHC.Maybe.Maybe a)
    -> (a -> m (GHC.Maybe.Maybe b)) -> m (GHC.Maybe.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,C(U),A)><L,U><L,C(U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: m (GHC.Maybe.Maybe a))
                   (w2 :: a -> m (GHC.Maybe.Maybe b)) ->
                 case w of ww { GHC.Base.C:Monad ww1 ww2 ww3 ww4 ww5 ->
                 Utils.Utils.$wmaybeM @ m @ a @ b ww2 ww4 w1 w2 }) -}
f2756b201e4878d9b4dadba434aad3e1
  moveOrCopy :: GHC.IO.FilePath -> GHC.IO.FilePath -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.Utils.moveOrCopy1
                  `cast`
                (<GHC.IO.FilePath>_R
                 ->_R <GHC.IO.FilePath>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
21f05d7c88bad9ea5312e736a30e1789
  moveOrCopy1 ::
    GHC.IO.FilePath
    -> GHC.IO.FilePath
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (oldfp :: GHC.IO.FilePath)
                   (newfp :: GHC.IO.FilePath)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 GHC.Prim.catch#
                   @ ()
                   @ GHC.Exception.Type.SomeException
                   (System.Directory.copyFile2 oldfp newfp)
                   (\ (e1 :: GHC.Exception.Type.SomeException)[OneShot]
                      (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                    case e1 of wild { GHC.Exception.Type.SomeException e2 $dException1 e3 ->
                    case Data.Typeable.Internal.sameTypeRep
                           @ *
                           @ *
                           @ e2
                           @ GHC.IO.Exception.IOException
                           (GHC.Exception.Type.$p1Exception @ e2 $dException1)
                             `cast`
                           (Data.Typeable.Internal.N:Typeable[0] <*>_N <e2>_N)
                           GHC.IO.Exception.$fExceptionIOException4 of wild1 {
                      GHC.Types.False
                      -> GHC.Prim.raiseIO#
                           @ GHC.Exception.Type.SomeException
                           @ ()
                           wild
                           eta1
                      GHC.Types.True
                      -> case e3
                                `cast`
                              (UnsafeCo representational e2 GHC.IO.Exception.IOException) of wild2 { GHC.IO.Exception.IOError ds1 ds2 ds3 ds4 ds5 ds6 ->
                         case ds2 of wild3 {
                           DEFAULT
                           -> GHC.Prim.raiseIO#
                                @ GHC.Exception.Type.SomeException
                                @ ()
                                (GHC.IO.Exception.$fExceptionIOException_$ctoException wild2)
                                eta1
                           GHC.IO.Exception.UnsupportedOperation
                           -> System.Directory.copyFile1 oldfp newfp eta1 } } } })
                   eta) -}
52a0bcb7ebc3f074ae8fd39e3fa5b882
  passthrough :: GHC.Base.Monad m => (a -> m ()) -> a -> m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(A,A,1*C1(C1(U)),1*C1(U),A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ m :: * -> *
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (f :: a -> m ())
                   (a1 :: a) ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ a
                   (f a1)
                   (GHC.Base.return @ m $dMonad @ a a1)) -}
c8186bbce386eb96c592af2149a83d9c
  secondM :: GHC.Base.Monad m => (a -> m b) -> (c, a) -> m (c, b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> * @ a @ b @ c ($dMonad :: GHC.Base.Monad m) ->
                 let {
                   $dFunctor :: GHC.Base.Applicative m = GHC.Base.$p1Monad @ m $dMonad
                 } in
                 let {
                   $dFunctor1 :: GHC.Base.Functor m
                   = GHC.Base.$p1Applicative @ m $dFunctor
                 } in
                 \ (f :: a -> m b) (ds :: (c, a)) ->
                 case ds of wild { (,) a1 c1 ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor1
                   @ b
                   @ (c, b)
                   (\ (ds1 :: b) -> (a1, ds1))
                   (f c1) }) -}
ba993310bf5265579655b8098370a058
  uniq :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, Strictness: <L,1*U(1*C(C(U)),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (x :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [a]
                      @ b1
                      (GHC.Base.mapFB @ a @ b1 @ [a] c (GHC.List.head @ a))
                      n
                      (Data.OldList.groupBy @ a (GHC.Classes.== @ a $dEq) x))) -}
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

