
==================== FINAL INTERFACE ====================
2020-02-24 04:14:33.367240328 UTC

interface NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5:Utils.Conduit 8065
  interface hash: 5b91d9a7768181fdd63224580906b8fc
  ABI hash: 3529d55b10a7cbdf7250fd156212ef77
  export-list hash: 899923d44363d2db775d0cbeb374b958
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: fcef9667fb8d4141406d92df6545362d
  opt_hash: 9851e58a0ec35d0fd39c07cdbeb6257b
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.Conduit.byteLineSinkHandle
  Utils.Conduit.byteLineVSinkHandle
  Utils.Conduit.linesC
  Utils.Conduit.linesVC
  Utils.Conduit.zipSink2
  Utils.Conduit.zipSource2
  Utils.Conduit.ByteLine{Utils.Conduit.ByteLine unwrapByteLine}
module dependencies: NGLess.NGError
package dependencies: array-0.5.3.0 base-4.12.0.0
                      bytestring-0.10.8.2 conduit-1.3.1.2 containers-0.6.0.1
                      deepseq-1.4.4.0 exceptions-0.10.4 ghc-boot-th-8.6.5 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0 mtl-2.2.2 primitive-0.6.4.0 resourcet-1.2.2
                      stm-2.5.0.0 template-haskell-2.14.0.0 transformers-0.5.6.2
                      unliftio-core-0.1.2.0 vector-0.12.0.3
orphans: vector-0.12.0.3:Data.Vector.Fusion.Bundle
         stm-2.5.0.0:Control.Monad.STM
         transformers-0.5.6.2:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5:NGLess.NGError
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         conduit-1.3.1.2:Data.Conduit.Internal.Conduit
                         conduit-1.3.1.2:Data.Conduit.Internal.Pipe
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         ghc-boot-th-8.6.5:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.5:GHC.LanguageExtensions.Type
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         resourcet-1.2.2:Control.Monad.Trans.Resource.Internal
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         vector-0.12.0.3:Data.Vector
import  -/  NGLess.NGError 9175c652eec68d1a195f3eb2d7471cb5
  exports: 500bdef9411bf7c9c4e288fc5b605d1e
  NGError 9741b2ef5fc8e673ccaf43057baf92e8
  throwDataError c062fbeafb6afe5ad95562e1e7cbc6a7
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Control.Monad.IO.Class e96805f9d79f75be66a0d44eb83064c1
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.Void 7d507f34fb7b7291298961d8e654089b
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.IO.Handle.Types 8909e00409cd23d4e66395a7e93f216d
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:System.IO dd4f3cfe73b94b7cae46a4ca98a3f09f
import  -/  bytestring-0.10.8.2:Data.ByteString fd8cecf441c361eb2e989315be3b33ab
import  -/  bytestring-0.10.8.2:Data.ByteString.Internal f8067c0775041a7adb8f53745475ed88
import  -/  conduit-1.3.1.2:Data.Conduit a386d3988254720545738ed91850d867
import  -/  conduit-1.3.1.2:Data.Conduit.Internal.Conduit 4cfa2d636f9204a4aa47382da9b0ff36
import  -/  conduit-1.3.1.2:Data.Conduit.List de08038b39705aaad9564275ec6efc45
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  mtl-2.2.2:Control.Monad.Error.Class 05ce857e0a8037d899cd3dba2eda1f68
import  -/  vector-0.12.0.3:Data.Vector c2b750be0d99dbce28ebfe75464ea17e
import  -/  vector-0.12.0.3:Data.Vector.Mutable 19d2c8fd8f32780e96cd889699bc033c
addDependentFile "/home/sajjal/.stack/programs/x86_64-linux/ghc-8.6.5/lib/ghc-8.6.5/include/ghcversion.h" 43db44f9bb88490c2fa995e5f5ec33f2
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-2.4.0.1/build/autogen/cabal_macros.h" e3731cb12b83b9e47defd67255252b42
addDependentFile "/usr/include/stdc-predef.h" 64086a4476ea583071277345b423d741
981aa5298d35f0c0dbe1b9a7c5c38f9d
  $fShowByteLine :: GHC.Show.Show Utils.Conduit.ByteLine
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Utils.Conduit.ByteLine
                  Utils.Conduit.$fShowByteLine_$cshowsPrec
                  Utils.Conduit.$fShowByteLine_$cshow
                  Utils.Conduit.$fShowByteLine_$cshowList -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  $fShowByteLine_$cshow :: Utils.Conduit.ByteLine -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U(U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Utils.Conduit.ByteLine) ->
                 Utils.Conduit.$fShowByteLine_$cshowsPrec
                   (GHC.Types.I# 0#)
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  $fShowByteLine_$cshowList ::
    [Utils.Conduit.ByteLine] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Utils.Conduit.ByteLine]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Utils.Conduit.ByteLine
                   (Utils.Conduit.$fShowByteLine_$cshowsPrec (GHC.Types.I# 0#))
                   ls
                   s) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  $fShowByteLine_$cshowsPrec ::
    GHC.Types.Int -> Utils.Conduit.ByteLine -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,U(U,U,U,U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Utils.Conduit.ByteLine) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Utils.Conduit.$w$cshowsPrec ww1 w1 }) -}
7a61920acc7ca37dc4435d9bf3587092
  $tc'ByteLine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1159642718707027235##
                   7351249543995928844##
                   Utils.Conduit.$trModule
                   Utils.Conduit.$tc'ByteLine2
                   0#
                   Utils.Conduit.$tc'ByteLine1) -}
787464f537004c04aada2f9228b7f444
  $tc'ByteLine1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
f65947bf2380205713ad0fac91661b05
  $tc'ByteLine2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Conduit.$tc'ByteLine3) -}
72004c2e8167d423fa7f0e44f5c9e628
  $tc'ByteLine3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ByteLine"#) -}
a91ba78cf2e9a6d671c0a6c06b2d3651
  $tcByteLine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10808499942712397109##
                   15716759122334928264##
                   Utils.Conduit.$trModule
                   Utils.Conduit.$tcByteLine1
                   0#
                   GHC.Types.krep$*) -}
b9b32403d9ba8fc5f3073b920cbefbae
  $tcByteLine1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Conduit.$tcByteLine2) -}
b90cfbd5a8eab2a062f3e9d89955de1a
  $tcByteLine2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ByteLine"#) -}
eba92d77c2896de978f484738c5ee305
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Utils.Conduit.$trModule3
                   Utils.Conduit.$trModule1) -}
5c38ee0eec3c24bcba89979f2efc9c00
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Conduit.$trModule2) -}
cc27f720b433ed850f0c8485ab6180ff
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils.Conduit"#) -}
d2573d2902b553fb7eeedf3ea391fc09
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.Conduit.$trModule4) -}
43644e1bd3be613575f3021bba8f3183
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("NGLess-1.1.0-965Np14lOUvJ2rS9XGhph5"#) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Utils.Conduit.ByteLine -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><L,U(U,U,U,U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Utils.Conduit.ByteLine) ->
                 let {
                   f :: GHC.Prim.Addr# = "ByteLine {"#
                 } in
                 let {
                   f1 :: [GHC.Types.Char] = GHC.CString.unpackCString# f
                 } in
                 let {
                   f2 :: GHC.Prim.Addr# = "unwrapByteLine = "#
                 } in
                 let {
                   f3 :: [GHC.Types.Char] = GHC.CString.unpackCString# f2
                 } in
                 let {
                   g :: GHC.Prim.Addr# = "}"#
                 } in
                 let {
                   g1 :: [GHC.Types.Char] = GHC.CString.unpackCString# g
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       f1
                       (GHC.Base.++
                          @ GHC.Types.Char
                          f3
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)3
                             (case w `cast`
                                   (Utils.Conduit.N:ByteLine[0]) of ww1 { Data.ByteString.Internal.PS ww2 ww3 ww4 ww5 ->
                              GHC.Show.showLitString
                                (Data.ByteString.Internal.$wunpackAppendCharsLazy
                                   ww2
                                   ww3
                                   ww4
                                   ww5
                                   (GHC.Types.[] @ GHC.Types.Char))
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Base.++ @ GHC.Types.Char g1 x)) })))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  newtype ByteLine
    = ByteLine {unwrapByteLine :: Data.ByteString.Internal.ByteString}
6f2a8561ae48069a20b7650aa09b45fc
  byteLineSinkHandle ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.IO.Handle.Types.Handle
    -> Data.Conduit.Internal.Conduit.ConduitT
         Utils.Conduit.ByteLine Data.Void.Void m ()
  {- Arity: 2, Strictness: <L,U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 \ (h :: GHC.IO.Handle.Types.Handle) ->
                 let {
                   nl :: Data.ByteString.Internal.ByteString
                   = Data.ByteString.singleton (GHC.Word.W8# 10##)
                 } in
                 let {
                   f :: Utils.Conduit.ByteLine -> m () {- Arity: 1 -}
                   = \ (ds :: Utils.Conduit.ByteLine) ->
                     Control.Monad.IO.Class.liftIO
                       @ m
                       $dMonadIO
                       @ ()
                       (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                        case Data.ByteString.appendFile2
                               h
                               ds `cast` (Utils.Conduit.N:ByteLine[0])
                               s of ds1 { (#,#) ipv ipv1 ->
                        Data.ByteString.appendFile2 h nl ipv })
                         `cast`
                       (Sym (GHC.Types.N:IO[0] <()>_R))
                 } in
                 Data.Conduit.Internal.Fusion.unstream
                   @ Utils.Conduit.ByteLine
                   @ Data.Void.Void
                   @ m
                   @ ()
                   (Data.Conduit.Internal.Fusion.ConduitWithStream
                      @ Utils.Conduit.ByteLine
                      @ Data.Void.Void
                      @ m
                      @ ()
                      (\ @ b
                         (rest :: ()
                                  -> Data.Conduit.Internal.Pipe.Pipe
                                       Utils.Conduit.ByteLine
                                       Utils.Conduit.ByteLine
                                       Data.Void.Void
                                       ()
                                       m
                                       b) ->
                       letrec {
                         go :: Data.Conduit.Internal.Pipe.Pipe
                                 Utils.Conduit.ByteLine Utils.Conduit.ByteLine Data.Void.Void () m b
                         = Data.Conduit.Internal.Pipe.NeedInput
                             @ Utils.Conduit.ByteLine
                             @ Utils.Conduit.ByteLine
                             @ Data.Void.Void
                             @ ()
                             @ m
                             @ b
                             go1
                             rest
                         lvl15 :: ()
                                  -> Data.Conduit.Internal.Pipe.Pipe
                                       Utils.Conduit.ByteLine
                                       Utils.Conduit.ByteLine
                                       Data.Void.Void
                                       ()
                                       m
                                       b
                           {- Arity: 1 -}
                         = \ (ds :: ()) -> go
                         go1 :: Utils.Conduit.ByteLine
                                -> Data.Conduit.Internal.Pipe.Pipe
                                     Utils.Conduit.ByteLine
                                     Utils.Conduit.ByteLine
                                     Data.Void.Void
                                     ()
                                     m
                                     b
                           {- Arity: 1 -}
                         = \ (i1 :: Utils.Conduit.ByteLine) ->
                           (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                              @ Utils.Conduit.ByteLine
                              @ Data.Void.Void
                              @ m
                              @ ()
                              $dMonad
                              (f i1))
                             `cast`
                           (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                <Utils.Conduit.ByteLine>_N <Data.Void.Void>_N <m>_N <()>_R)
                             @ b
                             lvl15
                       } in
                       go)
                        `cast`
                      (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                <Utils.Conduit.ByteLine>_N <Data.Void.Void>_N <m>_N <()>_R))
                      (Data.Conduit.Internal.List.Stream.mapM_S
                         @ m
                         @ Utils.Conduit.ByteLine
                         $dMonad
                         f
                         @ Data.Void.Void))) -}
986c66cf3ab3d1e44e7e9fc7daba4f09
  byteLineVSinkHandle ::
    Control.Monad.IO.Class.MonadIO m =>
    GHC.IO.Handle.Types.Handle
    -> Data.Conduit.Internal.Conduit.ConduitT
         (Data.Vector.Vector Utils.Conduit.ByteLine) Data.Void.Void m ()
  {- Arity: 2, Strictness: <L,U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ m :: * -> * ($dMonadIO :: Control.Monad.IO.Class.MonadIO m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 \ (h :: GHC.IO.Handle.Types.Handle) ->
                 let {
                   nl :: Data.ByteString.Internal.ByteString
                   = Data.ByteString.singleton (GHC.Word.W8# 10##)
                 } in
                 let {
                   f :: GHC.Types.IO () -> m ()
                   = Control.Monad.IO.Class.liftIO @ m $dMonadIO @ ()
                 } in
                 let {
                   f1 :: Utils.Conduit.ByteLine
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                     {- Arity: 2 -}
                   = \ (ds :: Utils.Conduit.ByteLine)
                       (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                     case Data.ByteString.appendFile2
                            h
                            ds `cast` (Utils.Conduit.N:ByteLine[0])
                            s of ds1 { (#,#) ipv ipv1 ->
                     Data.ByteString.appendFile2 h nl ipv }
                 } in
                 let {
                   f2 :: Data.Vector.Vector Utils.Conduit.ByteLine -> m ()
                     {- Arity: 1 -}
                   = \ (x :: Data.Vector.Vector Utils.Conduit.ByteLine) ->
                     f (Data.Vector.Fusion.Bundle.Monadic.mapM_
                          @ GHC.Types.IO
                          @ Utils.Conduit.ByteLine
                          @ ()
                          @ Data.Vector.Vector
                          GHC.Base.$fMonadIO
                          f1
                            `cast`
                          (<Utils.Conduit.ByteLine>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                          (Data.Vector.Fusion.Bundle.lift
                             @ GHC.Types.IO
                             @ Data.Vector.Vector
                             @ Utils.Conduit.ByteLine
                             GHC.Base.$fMonadIO
                             (Data.Vector.Generic.stream
                                @ Data.Vector.Vector
                                @ Utils.Conduit.ByteLine
                                (Data.Vector.$fVectorVectora @ Utils.Conduit.ByteLine)
                                x)))
                 } in
                 Data.Conduit.Internal.Fusion.unstream
                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                   @ Data.Void.Void
                   @ m
                   @ ()
                   (Data.Conduit.Internal.Fusion.ConduitWithStream
                      @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                      @ Data.Void.Void
                      @ m
                      @ ()
                      (\ @ b
                         (rest :: ()
                                  -> Data.Conduit.Internal.Pipe.Pipe
                                       (Data.Vector.Vector Utils.Conduit.ByteLine)
                                       (Data.Vector.Vector Utils.Conduit.ByteLine)
                                       Data.Void.Void
                                       ()
                                       m
                                       b) ->
                       letrec {
                         go :: Data.Conduit.Internal.Pipe.Pipe
                                 (Data.Vector.Vector Utils.Conduit.ByteLine)
                                 (Data.Vector.Vector Utils.Conduit.ByteLine)
                                 Data.Void.Void
                                 ()
                                 m
                                 b
                         = Data.Conduit.Internal.Pipe.NeedInput
                             @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                             @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                             @ Data.Void.Void
                             @ ()
                             @ m
                             @ b
                             go1
                             rest
                         lvl15 :: ()
                                  -> Data.Conduit.Internal.Pipe.Pipe
                                       (Data.Vector.Vector Utils.Conduit.ByteLine)
                                       (Data.Vector.Vector Utils.Conduit.ByteLine)
                                       Data.Void.Void
                                       ()
                                       m
                                       b
                           {- Arity: 1 -}
                         = \ (ds :: ()) -> go
                         go1 :: Data.Vector.Vector Utils.Conduit.ByteLine
                                -> Data.Conduit.Internal.Pipe.Pipe
                                     (Data.Vector.Vector Utils.Conduit.ByteLine)
                                     (Data.Vector.Vector Utils.Conduit.ByteLine)
                                     Data.Void.Void
                                     ()
                                     m
                                     b
                           {- Arity: 1 -}
                         = \ (i1 :: Data.Vector.Vector Utils.Conduit.ByteLine) ->
                           (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                              @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                              @ Data.Void.Void
                              @ m
                              @ ()
                              $dMonad
                              (f2 i1))
                             `cast`
                           (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                <Data.Void.Void>_N
                                <m>_N
                                <()>_R)
                             @ b
                             lvl15
                       } in
                       go)
                        `cast`
                      (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                <Data.Void.Void>_N
                                <m>_N
                                <()>_R))
                      (Data.Conduit.Internal.List.Stream.mapM_S
                         @ m
                         @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                         $dMonad
                         f2
                         @ Data.Void.Void))) -}
74def1591ec8f05f38349accac761045
  linesC ::
    Control.Monad.Error.Class.MonadError NGLess.NGError.NGError m =>
    Data.Conduit.Internal.Conduit.ConduitT
      Data.ByteString.Internal.ByteString Utils.Conduit.ByteLine m ()
  {- Arity: 2,
     Strictness: <L,U(U(A,C(C1(U)),A,C(U),A),C(U),A)><L,U>m2,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, False)
                (\ @ m :: * -> *
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      NGLess.NGError.NGError m) ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Error.Class.$p1MonadError
                       @ NGLess.NGError.NGError
                       @ m
                       $dMonadError
                 } in
                 letrec {
                   continue :: GHC.Types.Int
                               -> [Data.ByteString.Internal.ByteString]
                               -> Data.Conduit.Internal.Conduit.ConduitT
                                    Data.ByteString.Internal.ByteString Utils.Conduit.ByteLine m ()
                     {- Arity: 2 -}
                   = \ (n :: GHC.Types.Int)
                       (toks :: [Data.ByteString.Internal.ByteString]) ->
                     case GHC.Classes.gtInt n Utils.Conduit.maxLineSize of wild {
                       GHC.Types.False
                       -> let {
                            n1 :: Data.Conduit.Internal.Conduit.ConduitT
                                    Data.ByteString.Internal.ByteString Utils.Conduit.ByteLine m ()
                            = case GHC.Classes.gtInt n (GHC.Types.I# 0#) of wild1 {
                                GHC.Types.False
                                -> (\ @ b
                                      (ds :: ()
                                             -> Data.Conduit.Internal.Pipe.Pipe
                                                  Data.ByteString.Internal.ByteString
                                                  Data.ByteString.Internal.ByteString
                                                  Utils.Conduit.ByteLine
                                                  ()
                                                  m
                                                  b) ->
                                    ds GHC.Tuple.())
                                     `cast`
                                   (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                             <Data.ByteString.Internal.ByteString>_N
                                             <Utils.Conduit.ByteLine>_N
                                             <m>_N
                                             <()>_R))
                                GHC.Types.True
                                -> let {
                                     o1 :: Utils.Conduit.ByteLine
                                     = case toks of wild2 {
                                         []
                                         -> case GHC.Classes.leInt
                                                   (GHC.Types.I# 0#)
                                                   (GHC.Types.I# 0#) of wild3 {
                                              GHC.Types.False
                                              -> let {
                                                   n2 :: GHC.Types.Int = GHC.Types.I# -1#
                                                 } in
                                                 case GHC.Classes.ltInt
                                                        n2
                                                        (GHC.Types.I# 0#) of wild4 {
                                                   GHC.Types.False
                                                   -> case GHC.Classes.geInt
                                                             n2
                                                             (GHC.Types.I# 0#) of wild5 {
                                                        GHC.Types.False
                                                        -> case GHC.Prim.readWord8OffAddr#
                                                                  @ GHC.Prim.RealWorld
                                                                  (GHC.Prim.plusAddr# __NULL -1#)
                                                                  0#
                                                                  GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                                                           case GHC.Prim.touch#
                                                                  @ 'GHC.Types.LiftedRep
                                                                  @ GHC.ForeignPtr.ForeignPtrContents
                                                                  Data.ByteString.Internal.$fMonoidByteString1
                                                                  ipv of s' { DEFAULT ->
                                                           case GHC.Word.eqWord8
                                                                  (GHC.Word.W8# ipv1)
                                                                  (GHC.Word.W8# 13##) of wild6 {
                                                             GHC.Types.False
                                                             -> Data.ByteString.empty
                                                                  `cast`
                                                                (Sym (Utils.Conduit.N:ByteLine[0]))
                                                             GHC.Types.True
                                                             -> let {
                                                                  n3 :: GHC.Types.Int
                                                                  = GHC.Types.I# -1#
                                                                } in
                                                                case GHC.Classes.leInt
                                                                       n3
                                                                       (GHC.Types.I# 0#) of wild7 {
                                                                  GHC.Types.False
                                                                  -> case GHC.Classes.geInt
                                                                            n3
                                                                            (GHC.Types.I#
                                                                               0#) of wild8 {
                                                                       GHC.Types.False
                                                                       -> (Data.ByteString.Internal.$WPS
                                                                             (GHC.ForeignPtr.ForeignPtr
                                                                                @ GHC.Word.Word8
                                                                                __NULL
                                                                                Data.ByteString.Internal.$fMonoidByteString1)
                                                                             (GHC.Types.I# 0#)
                                                                             n3)
                                                                            `cast`
                                                                          (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                       GHC.Types.True
                                                                       -> Data.ByteString.empty
                                                                            `cast`
                                                                          (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                                  GHC.Types.True
                                                                  -> Data.ByteString.empty
                                                                       `cast`
                                                                     (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                                        GHC.Types.True
                                                        -> case Data.ByteString.moduleError
                                                                  @ GHC.Word.Word8
                                                                  (GHC.Base.build
                                                                     @ GHC.Types.Char
                                                                     (\ @ b ->
                                                                      GHC.CString.unpackFoldrCString#
                                                                        @ b
                                                                        "index"#))
                                                                  (GHC.Base.augment
                                                                     @ GHC.Types.Char
                                                                     (\ @ b
                                                                        (c :: GHC.Types.Char
                                                                              -> b -> b)[OneShot]
                                                                        (n3 :: b)[OneShot] ->
                                                                      GHC.CString.unpackFoldrCString#
                                                                        @ b
                                                                        "index too large: "#
                                                                        c
                                                                        n3)
                                                                     (GHC.Base.augment
                                                                        @ GHC.Types.Char
                                                                        (\ @ b
                                                                           (c :: GHC.Types.Char
                                                                                 -> b -> b)[OneShot]
                                                                           (n3 :: b)[OneShot] ->
                                                                         GHC.Base.foldr
                                                                           @ GHC.Types.Char
                                                                           @ b
                                                                           c
                                                                           n3
                                                                           (GHC.Show.showSignedInt
                                                                              GHC.Show.$fShow(,)1
                                                                              n2
                                                                              (GHC.Types.[]
                                                                                 @ GHC.Types.Char)))
                                                                        (GHC.Base.augment
                                                                           @ GHC.Types.Char
                                                                           (\ @ b
                                                                              (c :: GHC.Types.Char
                                                                                    -> b
                                                                                    -> b)[OneShot]
                                                                              (n3 :: b)[OneShot] ->
                                                                            GHC.CString.unpackFoldrCString#
                                                                              @ b
                                                                              ", length = "#
                                                                              c
                                                                              n3)
                                                                           (GHC.Show.showSignedInt
                                                                              GHC.Show.$fShow(,)1
                                                                              (GHC.Types.I# 0#)
                                                                              (GHC.Types.[]
                                                                                 @ GHC.Types.Char)))))
                                                           ret_ty Utils.Conduit.ByteLine
                                                           of {} }
                                                   GHC.Types.True
                                                   -> case Data.ByteString.moduleError
                                                             @ GHC.Word.Word8
                                                             (GHC.Base.build
                                                                @ GHC.Types.Char
                                                                (\ @ b ->
                                                                 GHC.CString.unpackFoldrCString#
                                                                   @ b
                                                                   "index"#))
                                                             (GHC.Base.augment
                                                                @ GHC.Types.Char
                                                                (\ @ b
                                                                   (c :: GHC.Types.Char
                                                                         -> b -> b)[OneShot]
                                                                   (n3 :: b)[OneShot] ->
                                                                 GHC.CString.unpackFoldrCString#
                                                                   @ b
                                                                   "negative index: "#
                                                                   c
                                                                   n3)
                                                                (GHC.Show.showSignedInt
                                                                   GHC.Show.$fShow(,)1
                                                                   n2
                                                                   (GHC.Types.[] @ GHC.Types.Char)))
                                                      ret_ty Utils.Conduit.ByteLine
                                                      of {} }
                                              GHC.Types.True
                                              -> Data.ByteString.empty
                                                   `cast`
                                                 (Sym (Utils.Conduit.N:ByteLine[0])) }
                                         : ipv ipv1
                                         -> case Data.ByteString.concat
                                                   (GHC.List.reverse1
                                                      @ Data.ByteString.Internal.ByteString
                                                      (GHC.Types.:
                                                         @ Data.ByteString.Internal.ByteString
                                                         Data.ByteString.empty
                                                         wild2)
                                                      (GHC.Types.[]
                                                         @ Data.ByteString.Internal.ByteString)) of wild3 { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                                            case GHC.Classes.leInt
                                                   (GHC.Types.I# dt3)
                                                   (GHC.Types.I# 0#) of wild4 {
                                              GHC.Types.False
                                              -> let {
                                                   n2 :: GHC.Prim.Int# = GHC.Prim.-# dt3 1#
                                                 } in
                                                 let {
                                                   n3 :: GHC.Types.Int = GHC.Types.I# n2
                                                 } in
                                                 case GHC.Classes.ltInt
                                                        n3
                                                        (GHC.Types.I# 0#) of wild5 {
                                                   GHC.Types.False
                                                   -> case GHC.Classes.geInt
                                                             n3
                                                             (GHC.Types.I# dt3) of wild6 {
                                                        GHC.Types.False
                                                        -> case GHC.Prim.readWord8OffAddr#
                                                                  @ GHC.Prim.RealWorld
                                                                  (GHC.Prim.plusAddr#
                                                                     dt
                                                                     (GHC.Prim.+# dt2 n2))
                                                                  0#
                                                                  GHC.Prim.realWorld# of ds2 { (#,#) ipv2 ipv3 ->
                                                           case GHC.Prim.touch#
                                                                  @ 'GHC.Types.LiftedRep
                                                                  @ GHC.ForeignPtr.ForeignPtrContents
                                                                  dt1
                                                                  ipv2 of s' { DEFAULT ->
                                                           case GHC.Word.eqWord8
                                                                  (GHC.Word.W8# ipv3)
                                                                  (GHC.Word.W8# 13##) of wild7 {
                                                             GHC.Types.False
                                                             -> wild3
                                                                  `cast`
                                                                (Sym (Utils.Conduit.N:ByteLine[0]))
                                                             GHC.Types.True
                                                             -> let {
                                                                  n4 :: GHC.Prim.Int#
                                                                  = GHC.Prim.-# dt3 1#
                                                                } in
                                                                let {
                                                                  n5 :: GHC.Types.Int
                                                                  = GHC.Types.I# n4
                                                                } in
                                                                case GHC.Classes.leInt
                                                                       n5
                                                                       (GHC.Types.I# 0#) of wild8 {
                                                                  GHC.Types.False
                                                                  -> case GHC.Classes.geInt
                                                                            n5
                                                                            (GHC.Types.I#
                                                                               dt3) of wild9 {
                                                                       GHC.Types.False
                                                                       -> (Data.ByteString.Internal.$WPS
                                                                             (GHC.ForeignPtr.ForeignPtr
                                                                                @ GHC.Word.Word8
                                                                                dt
                                                                                dt1)
                                                                             (GHC.Types.I# dt2)
                                                                             n5)
                                                                            `cast`
                                                                          (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                       GHC.Types.True
                                                                       -> wild3
                                                                            `cast`
                                                                          (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                                  GHC.Types.True
                                                                  -> Data.ByteString.empty
                                                                       `cast`
                                                                     (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                                        GHC.Types.True
                                                        -> case Data.ByteString.moduleError
                                                                  @ GHC.Word.Word8
                                                                  (GHC.Base.build
                                                                     @ GHC.Types.Char
                                                                     (\ @ b ->
                                                                      GHC.CString.unpackFoldrCString#
                                                                        @ b
                                                                        "index"#))
                                                                  (GHC.Base.augment
                                                                     @ GHC.Types.Char
                                                                     (\ @ b
                                                                        (c :: GHC.Types.Char
                                                                              -> b -> b)[OneShot]
                                                                        (n4 :: b)[OneShot] ->
                                                                      GHC.CString.unpackFoldrCString#
                                                                        @ b
                                                                        "index too large: "#
                                                                        c
                                                                        n4)
                                                                     (GHC.Base.augment
                                                                        @ GHC.Types.Char
                                                                        (\ @ b
                                                                           (c :: GHC.Types.Char
                                                                                 -> b -> b)[OneShot]
                                                                           (n4 :: b)[OneShot] ->
                                                                         GHC.Base.foldr
                                                                           @ GHC.Types.Char
                                                                           @ b
                                                                           c
                                                                           n4
                                                                           (GHC.Show.showSignedInt
                                                                              GHC.Show.$fShow(,)1
                                                                              n3
                                                                              (GHC.Types.[]
                                                                                 @ GHC.Types.Char)))
                                                                        (GHC.Base.augment
                                                                           @ GHC.Types.Char
                                                                           (\ @ b
                                                                              (c :: GHC.Types.Char
                                                                                    -> b
                                                                                    -> b)[OneShot]
                                                                              (n4 :: b)[OneShot] ->
                                                                            GHC.CString.unpackFoldrCString#
                                                                              @ b
                                                                              ", length = "#
                                                                              c
                                                                              n4)
                                                                           (GHC.Show.showSignedInt
                                                                              GHC.Show.$fShow(,)1
                                                                              (GHC.Types.I# dt3)
                                                                              (GHC.Types.[]
                                                                                 @ GHC.Types.Char)))))
                                                           ret_ty Utils.Conduit.ByteLine
                                                           of {} }
                                                   GHC.Types.True
                                                   -> case Data.ByteString.moduleError
                                                             @ GHC.Word.Word8
                                                             (GHC.Base.build
                                                                @ GHC.Types.Char
                                                                (\ @ b ->
                                                                 GHC.CString.unpackFoldrCString#
                                                                   @ b
                                                                   "index"#))
                                                             (GHC.Base.augment
                                                                @ GHC.Types.Char
                                                                (\ @ b
                                                                   (c :: GHC.Types.Char
                                                                         -> b -> b)[OneShot]
                                                                   (n4 :: b)[OneShot] ->
                                                                 GHC.CString.unpackFoldrCString#
                                                                   @ b
                                                                   "negative index: "#
                                                                   c
                                                                   n4)
                                                                (GHC.Show.showSignedInt
                                                                   GHC.Show.$fShow(,)1
                                                                   n3
                                                                   (GHC.Types.[] @ GHC.Types.Char)))
                                                      ret_ty Utils.Conduit.ByteLine
                                                      of {} }
                                              GHC.Types.True
                                              -> wild3
                                                   `cast`
                                                 (Sym (Utils.Conduit.N:ByteLine[0])) } } }
                                   } in
                                   (\ @ b
                                      (rest :: ()
                                               -> Data.Conduit.Internal.Pipe.Pipe
                                                    Data.ByteString.Internal.ByteString
                                                    Data.ByteString.Internal.ByteString
                                                    Utils.Conduit.ByteLine
                                                    ()
                                                    m
                                                    b) ->
                                    Data.Conduit.Internal.Pipe.HaveOutput
                                      @ Data.ByteString.Internal.ByteString
                                      @ Data.ByteString.Internal.ByteString
                                      @ Utils.Conduit.ByteLine
                                      @ ()
                                      @ m
                                      @ b
                                      (rest GHC.Tuple.())
                                      o1)
                                     `cast`
                                   (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                             <Data.ByteString.Internal.ByteString>_N
                                             <Utils.Conduit.ByteLine>_N
                                             <m>_N
                                             <()>_R)) }
                          } in
                          (\ @ b1
                             (h :: ()
                                   -> Data.Conduit.Internal.Pipe.Pipe
                                        Data.ByteString.Internal.ByteString
                                        Data.ByteString.Internal.ByteString
                                        Utils.Conduit.ByteLine
                                        ()
                                        m
                                        b1) ->
                           (Data.Conduit.Internal.Conduit.await
                              @ m
                              @ Data.ByteString.Internal.ByteString
                              $dMonad
                              @ Utils.Conduit.ByteLine)
                             `cast`
                           (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                <Data.ByteString.Internal.ByteString>_N
                                <Utils.Conduit.ByteLine>_N
                                <m>_N
                                <GHC.Maybe.Maybe Data.ByteString.Internal.ByteString>_R)
                             @ b1
                             (\ (a1 :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                              case a1 of wild1 {
                                GHC.Maybe.Nothing
                                -> n1
                                     `cast`
                                   (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                        <Data.ByteString.Internal.ByteString>_N
                                        <Utils.Conduit.ByteLine>_N
                                        <m>_N
                                        <()>_R)
                                     @ b1
                                     h
                                GHC.Maybe.Just x
                                -> (emit n toks x)
                                     `cast`
                                   (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                        <Data.ByteString.Internal.ByteString>_N
                                        <Utils.Conduit.ByteLine>_N
                                        <m>_N
                                        <()>_R)
                                     @ b1
                                     h }))
                            `cast`
                          (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                    <Data.ByteString.Internal.ByteString>_N
                                    <Utils.Conduit.ByteLine>_N
                                    <m>_N
                                    <()>_R))
                       GHC.Types.True
                       -> Data.Conduit.Internal.Conduit.$fMonadErroreConduitT_$cthrowError
                            @ NGLess.NGError.NGError
                            @ m
                            @ Data.ByteString.Internal.ByteString
                            @ Utils.Conduit.ByteLine
                            $dMonadError
                            @ ()
                            (case GHC.Base.build
                                    @ GHC.Types.Char
                                    (\ @ b
                                       (c :: GHC.Types.Char -> b -> b)[OneShot]
                                       (n1 :: b)[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Line too long (length is "#
                                       c
                                       (GHC.Base.foldr
                                          @ GHC.Types.Char
                                          @ b
                                          c
                                          (GHC.CString.unpackFoldrCString#
                                             @ b
                                             " characters)."#
                                             c
                                             n1)
                                          (GHC.Show.showSignedInt
                                             GHC.Show.$fShow(,)1
                                             n
                                             (GHC.Types.[] @ GHC.Types.Char)))) of dt { DEFAULT ->
                             NGLess.NGError.NGError NGLess.NGError.DataError dt }) }
                   emit :: GHC.Types.Int
                           -> [Data.ByteString.Internal.ByteString]
                           -> Data.ByteString.Internal.ByteString
                           -> Data.Conduit.Internal.Conduit.ConduitT
                                Data.ByteString.Internal.ByteString Utils.Conduit.ByteLine m ()
                     {- Arity: 3 -}
                   = \ (n :: GHC.Types.Int)
                       (toks :: [Data.ByteString.Internal.ByteString])
                       (tok :: Data.ByteString.Internal.ByteString) ->
                     case tok of wild { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                     let {
                       p' :: GHC.Prim.Addr# = GHC.Prim.plusAddr# dt dt2
                     } in
                     case {__pkg_ccall bytestring-0.10.8.2 GHC.Prim.Addr#
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Prim.Word#
                                                           -> GHC.Prim.State# GHC.Prim.RealWorld
                                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                 GHC.Prim.Addr# #)}
                            p'
                            10#
                            (GHC.Prim.int2Word# dt3)
                            GHC.Prim.realWorld# of wild2 { (#,#) ds4 ds5 ->
                     case GHC.Prim.eqAddr# ds5 __NULL of lwild {
                       DEFAULT
                       -> case GHC.Prim.touch#
                                 @ 'GHC.Types.LiftedRep
                                 @ GHC.ForeignPtr.ForeignPtrContents
                                 dt1
                                 ds4 of s' { DEFAULT ->
                          let {
                            ix :: GHC.Prim.Int# = GHC.Prim.minusAddr# ds5 p'
                          } in
                          let {
                            ix1 :: GHC.Types.Int = GHC.Types.I# ix
                          } in
                          let {
                            ds :: (Data.ByteString.Internal.ByteString,
                                   Data.ByteString.Internal.ByteString)
                            = let {
                                x :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8
                                = GHC.ForeignPtr.ForeignPtr @ GHC.Word.Word8 dt dt1
                              } in
                              case GHC.Classes.leInt ix1 (GHC.Types.I# 0#) of wild1 {
                                GHC.Types.False
                                -> case GHC.Classes.geInt ix1 (GHC.Types.I# dt3) of wild4 {
                                     GHC.Types.False
                                     -> (Data.ByteString.Internal.$WPS x (GHC.Types.I# dt2) ix1,
                                         Data.ByteString.Internal.$WPS
                                           x
                                           (GHC.Types.I# (GHC.Prim.+# dt2 ix))
                                           (GHC.Types.I# (GHC.Prim.-# dt3 ix)))
                                     GHC.Types.True -> (wild, Data.ByteString.empty) }
                                GHC.Types.True -> (Data.ByteString.empty, wild) }
                          } in
                          let {
                            o1 :: Utils.Conduit.ByteLine
                            = case toks of wild1 {
                                []
                                -> case ds of wild3 { (,) start rest ->
                                   case start of wild4 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                                   case GHC.Classes.leInt
                                          (GHC.Types.I# dt7)
                                          (GHC.Types.I# 0#) of wild5 {
                                     GHC.Types.False
                                     -> let {
                                          n1 :: GHC.Prim.Int# = GHC.Prim.-# dt7 1#
                                        } in
                                        let {
                                          n2 :: GHC.Types.Int = GHC.Types.I# n1
                                        } in
                                        case GHC.Classes.ltInt n2 (GHC.Types.I# 0#) of wild6 {
                                          GHC.Types.False
                                          -> case GHC.Classes.geInt n2 (GHC.Types.I# dt7) of wild7 {
                                               GHC.Types.False
                                               -> case GHC.Prim.readWord8OffAddr#
                                                         @ GHC.Prim.RealWorld
                                                         (GHC.Prim.plusAddr#
                                                            dt4
                                                            (GHC.Prim.+# dt6 n1))
                                                         0#
                                                         GHC.Prim.realWorld# of ds2 { (#,#) ipv ipv1 ->
                                                  case GHC.Prim.touch#
                                                         @ 'GHC.Types.LiftedRep
                                                         @ GHC.ForeignPtr.ForeignPtrContents
                                                         dt5
                                                         ipv of s'1 { DEFAULT ->
                                                  case GHC.Word.eqWord8
                                                         (GHC.Word.W8# ipv1)
                                                         (GHC.Word.W8# 13##) of wild8 {
                                                    GHC.Types.False
                                                    -> wild4
                                                         `cast`
                                                       (Sym (Utils.Conduit.N:ByteLine[0]))
                                                    GHC.Types.True
                                                    -> let {
                                                         n3 :: GHC.Prim.Int# = GHC.Prim.-# dt7 1#
                                                       } in
                                                       let {
                                                         n4 :: GHC.Types.Int = GHC.Types.I# n3
                                                       } in
                                                       case GHC.Classes.leInt
                                                              n4
                                                              (GHC.Types.I# 0#) of wild9 {
                                                         GHC.Types.False
                                                         -> case GHC.Classes.geInt
                                                                   n4
                                                                   (GHC.Types.I# dt7) of wild10 {
                                                              GHC.Types.False
                                                              -> (Data.ByteString.Internal.$WPS
                                                                    (GHC.ForeignPtr.ForeignPtr
                                                                       @ GHC.Word.Word8
                                                                       dt4
                                                                       dt5)
                                                                    (GHC.Types.I# dt6)
                                                                    n4)
                                                                   `cast`
                                                                 (Sym (Utils.Conduit.N:ByteLine[0]))
                                                              GHC.Types.True
                                                              -> wild4
                                                                   `cast`
                                                                 (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                         GHC.Types.True
                                                         -> Data.ByteString.empty
                                                              `cast`
                                                            (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                               GHC.Types.True
                                               -> case Data.ByteString.moduleError
                                                         @ GHC.Word.Word8
                                                         (GHC.Base.build
                                                            @ GHC.Types.Char
                                                            (\ @ b ->
                                                             GHC.CString.unpackFoldrCString#
                                                               @ b
                                                               "index"#))
                                                         (GHC.Base.augment
                                                            @ GHC.Types.Char
                                                            (\ @ b
                                                               (c :: GHC.Types.Char
                                                                     -> b -> b)[OneShot]
                                                               (n3 :: b)[OneShot] ->
                                                             GHC.CString.unpackFoldrCString#
                                                               @ b
                                                               "index too large: "#
                                                               c
                                                               n3)
                                                            (GHC.Base.augment
                                                               @ GHC.Types.Char
                                                               (\ @ b
                                                                  (c :: GHC.Types.Char
                                                                        -> b -> b)[OneShot]
                                                                  (n3 :: b)[OneShot] ->
                                                                GHC.Base.foldr
                                                                  @ GHC.Types.Char
                                                                  @ b
                                                                  c
                                                                  n3
                                                                  (GHC.Show.showSignedInt
                                                                     GHC.Show.$fShow(,)1
                                                                     n2
                                                                     (GHC.Types.[]
                                                                        @ GHC.Types.Char)))
                                                               (GHC.Base.augment
                                                                  @ GHC.Types.Char
                                                                  (\ @ b
                                                                     (c :: GHC.Types.Char
                                                                           -> b -> b)[OneShot]
                                                                     (n3 :: b)[OneShot] ->
                                                                   GHC.CString.unpackFoldrCString#
                                                                     @ b
                                                                     ", length = "#
                                                                     c
                                                                     n3)
                                                                  (GHC.Show.showSignedInt
                                                                     GHC.Show.$fShow(,)1
                                                                     (GHC.Types.I# dt7)
                                                                     (GHC.Types.[]
                                                                        @ GHC.Types.Char)))))
                                                  ret_ty Utils.Conduit.ByteLine
                                                  of {} }
                                          GHC.Types.True
                                          -> case Data.ByteString.moduleError
                                                    @ GHC.Word.Word8
                                                    (GHC.Base.build
                                                       @ GHC.Types.Char
                                                       (\ @ b ->
                                                        GHC.CString.unpackFoldrCString#
                                                          @ b
                                                          "index"#))
                                                    (GHC.Base.augment
                                                       @ GHC.Types.Char
                                                       (\ @ b
                                                          (c :: GHC.Types.Char -> b -> b)[OneShot]
                                                          (n3 :: b)[OneShot] ->
                                                        GHC.CString.unpackFoldrCString#
                                                          @ b
                                                          "negative index: "#
                                                          c
                                                          n3)
                                                       (GHC.Show.showSignedInt
                                                          GHC.Show.$fShow(,)1
                                                          n2
                                                          (GHC.Types.[] @ GHC.Types.Char)))
                                             ret_ty Utils.Conduit.ByteLine
                                             of {} }
                                     GHC.Types.True
                                     -> wild4 `cast` (Sym (Utils.Conduit.N:ByteLine[0])) } } }
                                : ipv ipv1
                                -> case Data.ByteString.concat
                                          (GHC.List.reverse1
                                             @ Data.ByteString.Internal.ByteString
                                             (GHC.Types.:
                                                @ Data.ByteString.Internal.ByteString
                                                (case ds of wild3 { (,) start rest -> start })
                                                wild1)
                                             (GHC.Types.[]
                                                @ Data.ByteString.Internal.ByteString)) of wild3 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                                   case GHC.Classes.leInt
                                          (GHC.Types.I# dt7)
                                          (GHC.Types.I# 0#) of wild4 {
                                     GHC.Types.False
                                     -> let {
                                          n1 :: GHC.Prim.Int# = GHC.Prim.-# dt7 1#
                                        } in
                                        let {
                                          n2 :: GHC.Types.Int = GHC.Types.I# n1
                                        } in
                                        case GHC.Classes.ltInt n2 (GHC.Types.I# 0#) of wild5 {
                                          GHC.Types.False
                                          -> case GHC.Classes.geInt n2 (GHC.Types.I# dt7) of wild6 {
                                               GHC.Types.False
                                               -> case GHC.Prim.readWord8OffAddr#
                                                         @ GHC.Prim.RealWorld
                                                         (GHC.Prim.plusAddr#
                                                            dt4
                                                            (GHC.Prim.+# dt6 n1))
                                                         0#
                                                         GHC.Prim.realWorld# of ds2 { (#,#) ipv2 ipv3 ->
                                                  case GHC.Prim.touch#
                                                         @ 'GHC.Types.LiftedRep
                                                         @ GHC.ForeignPtr.ForeignPtrContents
                                                         dt5
                                                         ipv2 of s'1 { DEFAULT ->
                                                  case GHC.Word.eqWord8
                                                         (GHC.Word.W8# ipv3)
                                                         (GHC.Word.W8# 13##) of wild7 {
                                                    GHC.Types.False
                                                    -> wild3
                                                         `cast`
                                                       (Sym (Utils.Conduit.N:ByteLine[0]))
                                                    GHC.Types.True
                                                    -> let {
                                                         n3 :: GHC.Prim.Int# = GHC.Prim.-# dt7 1#
                                                       } in
                                                       let {
                                                         n4 :: GHC.Types.Int = GHC.Types.I# n3
                                                       } in
                                                       case GHC.Classes.leInt
                                                              n4
                                                              (GHC.Types.I# 0#) of wild8 {
                                                         GHC.Types.False
                                                         -> case GHC.Classes.geInt
                                                                   n4
                                                                   (GHC.Types.I# dt7) of wild9 {
                                                              GHC.Types.False
                                                              -> (Data.ByteString.Internal.$WPS
                                                                    (GHC.ForeignPtr.ForeignPtr
                                                                       @ GHC.Word.Word8
                                                                       dt4
                                                                       dt5)
                                                                    (GHC.Types.I# dt6)
                                                                    n4)
                                                                   `cast`
                                                                 (Sym (Utils.Conduit.N:ByteLine[0]))
                                                              GHC.Types.True
                                                              -> wild3
                                                                   `cast`
                                                                 (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                         GHC.Types.True
                                                         -> Data.ByteString.empty
                                                              `cast`
                                                            (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                               GHC.Types.True
                                               -> case Data.ByteString.moduleError
                                                         @ GHC.Word.Word8
                                                         (GHC.Base.build
                                                            @ GHC.Types.Char
                                                            (\ @ b ->
                                                             GHC.CString.unpackFoldrCString#
                                                               @ b
                                                               "index"#))
                                                         (GHC.Base.augment
                                                            @ GHC.Types.Char
                                                            (\ @ b
                                                               (c :: GHC.Types.Char
                                                                     -> b -> b)[OneShot]
                                                               (n3 :: b)[OneShot] ->
                                                             GHC.CString.unpackFoldrCString#
                                                               @ b
                                                               "index too large: "#
                                                               c
                                                               n3)
                                                            (GHC.Base.augment
                                                               @ GHC.Types.Char
                                                               (\ @ b
                                                                  (c :: GHC.Types.Char
                                                                        -> b -> b)[OneShot]
                                                                  (n3 :: b)[OneShot] ->
                                                                GHC.Base.foldr
                                                                  @ GHC.Types.Char
                                                                  @ b
                                                                  c
                                                                  n3
                                                                  (GHC.Show.showSignedInt
                                                                     GHC.Show.$fShow(,)1
                                                                     n2
                                                                     (GHC.Types.[]
                                                                        @ GHC.Types.Char)))
                                                               (GHC.Base.augment
                                                                  @ GHC.Types.Char
                                                                  (\ @ b
                                                                     (c :: GHC.Types.Char
                                                                           -> b -> b)[OneShot]
                                                                     (n3 :: b)[OneShot] ->
                                                                   GHC.CString.unpackFoldrCString#
                                                                     @ b
                                                                     ", length = "#
                                                                     c
                                                                     n3)
                                                                  (GHC.Show.showSignedInt
                                                                     GHC.Show.$fShow(,)1
                                                                     (GHC.Types.I# dt7)
                                                                     (GHC.Types.[]
                                                                        @ GHC.Types.Char)))))
                                                  ret_ty Utils.Conduit.ByteLine
                                                  of {} }
                                          GHC.Types.True
                                          -> case Data.ByteString.moduleError
                                                    @ GHC.Word.Word8
                                                    (GHC.Base.build
                                                       @ GHC.Types.Char
                                                       (\ @ b ->
                                                        GHC.CString.unpackFoldrCString#
                                                          @ b
                                                          "index"#))
                                                    (GHC.Base.augment
                                                       @ GHC.Types.Char
                                                       (\ @ b
                                                          (c :: GHC.Types.Char -> b -> b)[OneShot]
                                                          (n3 :: b)[OneShot] ->
                                                        GHC.CString.unpackFoldrCString#
                                                          @ b
                                                          "negative index: "#
                                                          c
                                                          n3)
                                                       (GHC.Show.showSignedInt
                                                          GHC.Show.$fShow(,)1
                                                          n2
                                                          (GHC.Types.[] @ GHC.Types.Char)))
                                             ret_ty Utils.Conduit.ByteLine
                                             of {} }
                                     GHC.Types.True
                                     -> wild3 `cast` (Sym (Utils.Conduit.N:ByteLine[0])) } } }
                          } in
                          let {
                            k :: Data.Conduit.Internal.Conduit.ConduitT
                                   Data.ByteString.Internal.ByteString Utils.Conduit.ByteLine m ()
                            = emit
                                (GHC.Types.I# 0#)
                                (GHC.Types.[] @ Data.ByteString.Internal.ByteString)
                                (case ds of wild1 { (,) start rest ->
                                 case rest of wild3 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt7 ->
                                 case GHC.Classes.leInt
                                        (GHC.Types.I# dt7)
                                        (GHC.Types.I# 0#) of wild4 {
                                   GHC.Types.False
                                   -> Data.ByteString.Internal.$WPS
                                        (GHC.ForeignPtr.ForeignPtr @ GHC.Word.Word8 dt4 dt5)
                                        (GHC.Types.I# (GHC.Prim.+# dt6 1#))
                                        (GHC.Types.I# (GHC.Prim.-# dt7 1#))
                                   GHC.Types.True
                                   -> Data.ByteString.errorEmptyList
                                        @ Data.ByteString.Internal.ByteString
                                        (GHC.Base.build
                                           @ GHC.Types.Char
                                           (\ @ b ->
                                            GHC.CString.unpackFoldrCString# @ b "tail"#)) } } })
                          } in
                          (\ @ b1
                             (h :: ()
                                   -> Data.Conduit.Internal.Pipe.Pipe
                                        Data.ByteString.Internal.ByteString
                                        Data.ByteString.Internal.ByteString
                                        Utils.Conduit.ByteLine
                                        ()
                                        m
                                        b1) ->
                           Data.Conduit.Internal.Pipe.HaveOutput
                             @ Data.ByteString.Internal.ByteString
                             @ Data.ByteString.Internal.ByteString
                             @ Utils.Conduit.ByteLine
                             @ ()
                             @ m
                             @ b1
                             (k `cast`
                              (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                   <Data.ByteString.Internal.ByteString>_N
                                   <Utils.Conduit.ByteLine>_N
                                   <m>_N
                                   <()>_R)
                                @ b1
                                h)
                             o1)
                            `cast`
                          (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                    <Data.ByteString.Internal.ByteString>_N
                                    <Utils.Conduit.ByteLine>_N
                                    <m>_N
                                    <()>_R)) }
                       1#
                       -> case GHC.Prim.touch#
                                 @ 'GHC.Types.LiftedRep
                                 @ GHC.ForeignPtr.ForeignPtrContents
                                 dt1
                                 ds4 of s' { DEFAULT ->
                          continue
                            (case n of wild1 { GHC.Types.I# x ->
                             GHC.Types.I# (GHC.Prim.+# x dt3) })
                            (GHC.Types.:
                               @ Data.ByteString.Internal.ByteString
                               wild
                               toks) } } } }
                 } in
                 continue
                   (GHC.Types.I# 0#)
                   (GHC.Types.[] @ Data.ByteString.Internal.ByteString)) -}
5f60b94589835a466cc14354f9554195
  linesVC ::
    (Control.Monad.IO.Class.MonadIO m,
     Control.Monad.Error.Class.MonadError NGLess.NGError.NGError m) =>
    GHC.Types.Int
    -> Data.Conduit.Internal.Conduit.ConduitT
         Data.ByteString.Internal.ByteString
         (Data.Vector.Vector Utils.Conduit.ByteLine)
         m
         ()
  {- Arity: 3,
     Strictness: <L,U(1*U(A,C(C1(U)),A,C(U),A),C(U))><L,U(U(A,C(C1(U)),A,C(U),A),C(U),A)><L,U(U)>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   ($dMonadIO :: Control.Monad.IO.Class.MonadIO m)
                   ($dMonadError :: Control.Monad.Error.Class.MonadError
                                      NGLess.NGError.NGError m)
                   (nlines :: GHC.Types.Int) ->
                 let {
                   f :: GHC.Base.Monad m
                   = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                 } in
                 let {
                   ds :: m (Data.Vector.Mutable.MVector
                              GHC.Prim.RealWorld Utils.Conduit.ByteLine)
                   = Control.Monad.IO.Class.liftIO
                       @ m
                       $dMonadIO
                       @ (Data.Vector.Mutable.MVector
                            GHC.Prim.RealWorld Utils.Conduit.ByteLine)
                       (case GHC.Classes.geInt nlines (GHC.Types.I# 0#) of wild1 {
                          GHC.Types.False
                          -> case nlines of wild { GHC.Types.I# n# ->
                             (Data.Vector.Internal.Check.checkError
                                @ (GHC.Types.IO
                                     (Data.Vector.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState GHC.Types.IO)
                                        Utils.Conduit.ByteLine))
                                (GHC.Base.build
                                   @ GHC.Types.Char
                                   (\ @ b ->
                                    GHC.CString.unpackFoldrCString#
                                      @ b
                                      "./Data/Vector/Generic/Mutable.hs"#))
                                (GHC.Types.I# 585#)
                                Data.Vector.Internal.Check.Bounds
                                (GHC.Base.build
                                   @ GHC.Types.Char
                                   (\ @ b -> GHC.CString.unpackFoldrCString# @ b "new"#))
                                (Data.Vector.Internal.Check.checkLength_msg# n#))
                               `cast`
                             (GHC.Types.IO
                                (Data.Vector.Mutable.MVector
                                   (Control.Monad.Primitive.D:R:PrimStateIO[0])
                                   <Utils.Conduit.ByteLine>_R)_R)_R }
                          GHC.Types.True
                          -> (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                              case nlines of wild { GHC.Types.I# n# ->
                              case GHC.Prim.newArray#
                                     @ Utils.Conduit.ByteLine
                                     @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                                     n#
                                     (Data.Vector.Mutable.uninitialised @ Utils.Conduit.ByteLine)
                                     s `cast`
                                     (Nth:2
                                          ((GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                           ->_R ((#,#)
                                                   <'GHC.Types.TupleRep '[]>_R
                                                   <'GHC.Types.LiftedRep>_R
                                                   (GHC.Prim.State#
                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                   <Data.Primitive.Array.MutableArray
                                                      (Control.Monad.Primitive.PrimState
                                                         GHC.Types.IO)
                                                      Utils.Conduit.ByteLine>_R)_R)) of ds1 { (#,#) ipv ipv1 ->
                              (# ipv
                                   `cast`
                                 (Nth:2
                                      (Nth:3
                                           ((GHC.Prim.State#
                                               (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                            ->_R ((#,#)
                                                    <'GHC.Types.TupleRep '[]>_R
                                                    <'GHC.Types.LiftedRep>_R
                                                    (GHC.Prim.State#
                                                       (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                    <Data.Primitive.Array.MutableArray
                                                       (Control.Monad.Primitive.PrimState
                                                          GHC.Types.IO)
                                                       Utils.Conduit.ByteLine>_R)_R))),
                                 Data.Vector.Mutable.$WMVector
                                   @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                                   @ Utils.Conduit.ByteLine
                                   (GHC.Types.I# 0#)
                                   wild
                                   (Data.Primitive.Array.MutableArray
                                      @ (Control.Monad.Primitive.PrimState GHC.Types.IO)
                                      @ Utils.Conduit.ByteLine
                                      ipv1) #) } })
                               `cast`
                             (Sym (GHC.Types.N:IO[0]
                                       (Data.Vector.Mutable.MVector
                                          (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0]))
                                          <Utils.Conduit.ByteLine>_R)_R)) })
                 } in
                 (\ @ b1
                    (h :: ()
                          -> Data.Conduit.Internal.Pipe.Pipe
                               Data.ByteString.Internal.ByteString
                               Data.ByteString.Internal.ByteString
                               (Data.Vector.Vector Utils.Conduit.ByteLine)
                               ()
                               m
                               b1) ->
                  (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                     @ Data.ByteString.Internal.ByteString
                     @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                     @ m
                     @ (Data.Vector.Mutable.MVector
                          GHC.Prim.RealWorld Utils.Conduit.ByteLine)
                     f
                     ds)
                    `cast`
                  (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                       <Data.ByteString.Internal.ByteString>_N
                       <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                       <m>_N
                       <Data.Vector.Mutable.MVector
                          GHC.Prim.RealWorld Utils.Conduit.ByteLine>_R)
                    @ b1
                    (\ (a1 :: Data.Vector.Mutable.MVector
                                GHC.Prim.RealWorld Utils.Conduit.ByteLine) ->
                     let {
                       $dMonad :: GHC.Base.Monad m
                       = Control.Monad.Error.Class.$p1MonadError
                           @ NGLess.NGError.NGError
                           @ m
                           $dMonadError
                     } in
                     letrec {
                       continue :: Data.Vector.Mutable.MVector
                                     GHC.Prim.RealWorld Utils.Conduit.ByteLine
                                   -> GHC.Types.Int
                                   -> GHC.Types.Int
                                   -> [Data.ByteString.Internal.ByteString]
                                   -> Data.Conduit.Internal.Conduit.ConduitT
                                        Data.ByteString.Internal.ByteString
                                        (Data.Vector.Vector Utils.Conduit.ByteLine)
                                        m
                                        ()
                         {- Arity: 4 -}
                       = \ (vec :: Data.Vector.Mutable.MVector
                                     GHC.Prim.RealWorld Utils.Conduit.ByteLine)
                           (vix :: GHC.Types.Int)
                           (n :: GHC.Types.Int)
                           (toks :: [Data.ByteString.Internal.ByteString]) ->
                         case GHC.Classes.gtInt n Utils.Conduit.maxLineSize of wild {
                           GHC.Types.False
                           -> let {
                                n1 :: Data.Conduit.Internal.Conduit.ConduitT
                                        Data.ByteString.Internal.ByteString
                                        (Data.Vector.Vector Utils.Conduit.ByteLine)
                                        m
                                        ()
                                = letrec {
                                    finish :: Data.Vector.Mutable.MVector
                                                GHC.Prim.RealWorld Utils.Conduit.ByteLine
                                              -> GHC.Types.Int
                                              -> [Data.ByteString.Internal.ByteString]
                                              -> Data.Conduit.Internal.Conduit.ConduitT
                                                   Data.ByteString.Internal.ByteString
                                                   (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   m
                                                   ()
                                      {- Arity: 3 -}
                                    = \ (ds1 :: Data.Vector.Mutable.MVector
                                                  GHC.Prim.RealWorld Utils.Conduit.ByteLine)
                                        (ds2 :: GHC.Types.Int)
                                        (ds3 :: [Data.ByteString.Internal.ByteString]) ->
                                      let {
                                        fail :: GHC.Prim.Void#
                                                -> Data.Conduit.Internal.Conduit.ConduitT
                                                     Data.ByteString.Internal.ByteString
                                                     (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                     m
                                                     ()
                                          <join 1> {- Arity: 1 -}
                                        = \ (ds4 :: GHC.Prim.Void#)[OneShot] ->
                                          case ds3 of wild1 {
                                            []
                                            -> let {
                                                 f1 :: GHC.Base.Monad m
                                                 = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                                               } in
                                               let {
                                                 ds5 :: m (Data.Vector.Vector
                                                             Utils.Conduit.ByteLine)
                                                 = Control.Monad.IO.Class.liftIO
                                                     @ m
                                                     $dMonadIO
                                                     @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                     (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                      case ds1
                                                             `cast`
                                                           (Data.Vector.Mutable.MVector
                                                              (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0]))
                                                              <Utils.Conduit.ByteLine>_R)_R of wild2 { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                                      case GHC.Prim.unsafeFreezeArray#
                                                             @ (Control.Monad.Primitive.PrimState
                                                                  GHC.Types.IO)
                                                             @ Utils.Conduit.ByteLine
                                                             dt2
                                                             s `cast`
                                                             (Nth:2
                                                                  ((GHC.Prim.State#
                                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                   ->_R ((#,#)
                                                                           <'GHC.Types.TupleRep
                                                                              '[]>_R
                                                                           <'GHC.Types.LiftedRep>_R
                                                                           (GHC.Prim.State#
                                                                              (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                           <Data.Primitive.Array.Array
                                                                              Utils.Conduit.ByteLine>_R)_R)) of ds6 { (#,#) ipv ipv1 ->
                                                      (# ipv
                                                           `cast`
                                                         (Nth:2
                                                              (Nth:3
                                                                   ((GHC.Prim.State#
                                                                       (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                    ->_R ((#,#)
                                                                            <'GHC.Types.TupleRep
                                                                               '[]>_R
                                                                            <'GHC.Types.LiftedRep>_R
                                                                            (GHC.Prim.State#
                                                                               (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                            <Data.Primitive.Array.Array
                                                                               Utils.Conduit.ByteLine>_R)_R))),
                                                         Data.Vector.Generic.unsafeSlice
                                                           @ Data.Vector.Vector
                                                           @ Utils.Conduit.ByteLine
                                                           (Data.Vector.$fVectorVectora
                                                              @ Utils.Conduit.ByteLine)
                                                           (GHC.Types.I# 0#)
                                                           ds2
                                                           (Data.Vector.$WVector
                                                              @ Utils.Conduit.ByteLine
                                                              (GHC.Types.I# dt)
                                                              (GHC.Types.I# dt1)
                                                              (Data.Primitive.Array.Array
                                                                 @ Utils.Conduit.ByteLine
                                                                 ipv1)) #) } })
                                                       `cast`
                                                     (Sym (GHC.Types.N:IO[0]
                                                               <Data.Vector.Vector
                                                                  Utils.Conduit.ByteLine>_R))
                                               } in
                                               (\ @ b2
                                                  (h1 :: ()
                                                         -> Data.Conduit.Internal.Pipe.Pipe
                                                              Data.ByteString.Internal.ByteString
                                                              Data.ByteString.Internal.ByteString
                                                              (Data.Vector.Vector
                                                                 Utils.Conduit.ByteLine)
                                                              ()
                                                              m
                                                              b2) ->
                                                (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                                                   @ Data.ByteString.Internal.ByteString
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   @ m
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   f1
                                                   ds5)
                                                  `cast`
                                                (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                     <Data.ByteString.Internal.ByteString>_N
                                                     <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                                     <m>_N
                                                     <Data.Vector.Vector Utils.Conduit.ByteLine>_R)
                                                  @ b2
                                                  (\ (a2 :: Data.Vector.Vector
                                                              Utils.Conduit.ByteLine) ->
                                                   Data.Conduit.Internal.Pipe.HaveOutput
                                                     @ Data.ByteString.Internal.ByteString
                                                     @ Data.ByteString.Internal.ByteString
                                                     @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                     @ ()
                                                     @ m
                                                     @ b2
                                                     (h1 GHC.Tuple.())
                                                     a2))
                                                 `cast`
                                               (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                         <Data.ByteString.Internal.ByteString>_N
                                                         <Data.Vector.Vector
                                                            Utils.Conduit.ByteLine>_N
                                                         <m>_N
                                                         <()>_R))
                                            : ipv ipv1
                                            -> let {
                                                 f1 :: GHC.Base.Monad m
                                                 = Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO
                                               } in
                                               let {
                                                 m1 :: m ()
                                                 = Control.Monad.IO.Class.liftIO
                                                     @ m
                                                     $dMonadIO
                                                     @ ()
                                                     (let {
                                                        file :: GHC.Base.String
                                                        = GHC.Base.build
                                                            @ GHC.Types.Char
                                                            (\ @ b ->
                                                             GHC.CString.unpackFoldrCString#
                                                               @ b
                                                               "./Data/Vector/Generic/Mutable.hs"#)
                                                      } in
                                                      case GHC.Classes.geInt
                                                             ds2
                                                             (GHC.Types.I# 0#) of wild2 {
                                                        GHC.Types.False
                                                        -> case ds2 of wild3 { GHC.Types.I# i# ->
                                                           case ds1
                                                                  `cast`
                                                                (Data.Vector.Mutable.MVector
                                                                   (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0]))
                                                                   <Utils.Conduit.ByteLine>_R)_R of wild4 { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                                           Data.Vector.Internal.Check.checkError
                                                             @ (GHC.Types.IO ())
                                                             file
                                                             (GHC.Types.I# 697#)
                                                             Data.Vector.Internal.Check.Bounds
                                                             (GHC.Base.build
                                                                @ GHC.Types.Char
                                                                (\ @ b ->
                                                                 GHC.CString.unpackFoldrCString#
                                                                   @ b
                                                                   "write"#))
                                                             (Data.Vector.Internal.Check.checkIndex_msg#
                                                                i#
                                                                dt1) } }
                                                        GHC.Types.True
                                                        -> case ds1
                                                                  `cast`
                                                                (Data.Vector.Mutable.MVector
                                                                   (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0]))
                                                                   <Utils.Conduit.ByteLine>_R)_R of wild3 { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                                           case GHC.Classes.ltInt
                                                                  ds2
                                                                  (GHC.Types.I# dt1) of wild4 {
                                                             GHC.Types.False
                                                             -> case ds2 of wild5 { GHC.Types.I# i# ->
                                                                Data.Vector.Internal.Check.checkError
                                                                  @ (GHC.Types.IO ())
                                                                  file
                                                                  (GHC.Types.I# 697#)
                                                                  Data.Vector.Internal.Check.Bounds
                                                                  (GHC.Base.build
                                                                     @ GHC.Types.Char
                                                                     (\ @ b ->
                                                                      GHC.CString.unpackFoldrCString#
                                                                        @ b
                                                                        "write"#))
                                                                  (Data.Vector.Internal.Check.checkIndex_msg#
                                                                     i#
                                                                     dt1) }
                                                             GHC.Types.True
                                                             -> case ds2 of wild5 { GHC.Types.I# y ->
                                                                (\ (s# :: GHC.Prim.State#
                                                                            (Control.Monad.Primitive.PrimState
                                                                               GHC.Types.IO)) ->
                                                                 case GHC.Prim.writeArray#
                                                                        @ (Control.Monad.Primitive.PrimState
                                                                             GHC.Types.IO)
                                                                        @ Utils.Conduit.ByteLine
                                                                        dt2
                                                                        (GHC.Prim.+# dt y)
                                                                        (case Data.ByteString.concat
                                                                                (GHC.List.reverse1
                                                                                   @ Data.ByteString.Internal.ByteString
                                                                                   wild1
                                                                                   (GHC.Types.[]
                                                                                      @ Data.ByteString.Internal.ByteString)) of wild6 { Data.ByteString.Internal.PS dt4 dt5 dt6 dt3 ->
                                                                         case GHC.Classes.leInt
                                                                                (GHC.Types.I# dt3)
                                                                                (GHC.Types.I#
                                                                                   0#) of wild7 {
                                                                           GHC.Types.False
                                                                           -> let {
                                                                                n2 :: GHC.Prim.Int#
                                                                                = GHC.Prim.-# dt3 1#
                                                                              } in
                                                                              let {
                                                                                n3 :: GHC.Types.Int
                                                                                = GHC.Types.I# n2
                                                                              } in
                                                                              case GHC.Classes.ltInt
                                                                                     n3
                                                                                     (GHC.Types.I#
                                                                                        0#) of wild8 {
                                                                                GHC.Types.False
                                                                                -> case GHC.Classes.geInt
                                                                                          n3
                                                                                          (GHC.Types.I#
                                                                                             dt3) of wild9 {
                                                                                     GHC.Types.False
                                                                                     -> case GHC.Prim.readWord8OffAddr#
                                                                                               @ GHC.Prim.RealWorld
                                                                                               (GHC.Prim.plusAddr#
                                                                                                  dt4
                                                                                                  (GHC.Prim.+#
                                                                                                     dt6
                                                                                                     n2))
                                                                                               0#
                                                                                               GHC.Prim.realWorld# of ds5 { (#,#) ipv2 ipv3 ->
                                                                                        case GHC.Prim.touch#
                                                                                               @ 'GHC.Types.LiftedRep
                                                                                               @ GHC.ForeignPtr.ForeignPtrContents
                                                                                               dt5
                                                                                               ipv2 of s' { DEFAULT ->
                                                                                        case GHC.Word.eqWord8
                                                                                               (GHC.Word.W8#
                                                                                                  ipv3)
                                                                                               (GHC.Word.W8#
                                                                                                  13##) of wild10 {
                                                                                          GHC.Types.False
                                                                                          -> wild6
                                                                                               `cast`
                                                                                             (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                          GHC.Types.True
                                                                                          -> let {
                                                                                               n4 :: GHC.Prim.Int#
                                                                                               = GHC.Prim.-#
                                                                                                   dt3
                                                                                                   1#
                                                                                             } in
                                                                                             let {
                                                                                               n5 :: GHC.Types.Int
                                                                                               = GHC.Types.I#
                                                                                                   n4
                                                                                             } in
                                                                                             case GHC.Classes.leInt
                                                                                                    n5
                                                                                                    (GHC.Types.I#
                                                                                                       0#) of wild11 {
                                                                                               GHC.Types.False
                                                                                               -> case GHC.Classes.geInt
                                                                                                         n5
                                                                                                         (GHC.Types.I#
                                                                                                            dt3) of wild12 {
                                                                                                    GHC.Types.False
                                                                                                    -> (Data.ByteString.Internal.$WPS
                                                                                                          (GHC.ForeignPtr.ForeignPtr
                                                                                                             @ GHC.Word.Word8
                                                                                                             dt4
                                                                                                             dt5)
                                                                                                          (GHC.Types.I#
                                                                                                             dt6)
                                                                                                          n5)
                                                                                                         `cast`
                                                                                                       (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                                    GHC.Types.True
                                                                                                    -> wild6
                                                                                                         `cast`
                                                                                                       (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                                                               GHC.Types.True
                                                                                               -> Data.ByteString.empty
                                                                                                    `cast`
                                                                                                  (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                                                                     GHC.Types.True
                                                                                     -> case Data.ByteString.moduleError
                                                                                               @ GHC.Word.Word8
                                                                                               (GHC.Base.build
                                                                                                  @ GHC.Types.Char
                                                                                                  (\ @ b ->
                                                                                                   GHC.CString.unpackFoldrCString#
                                                                                                     @ b
                                                                                                     "index"#))
                                                                                               (GHC.Base.augment
                                                                                                  @ GHC.Types.Char
                                                                                                  (\ @ b
                                                                                                     (c :: GHC.Types.Char
                                                                                                           -> b
                                                                                                           -> b)[OneShot]
                                                                                                     (n4 :: b)[OneShot] ->
                                                                                                   GHC.CString.unpackFoldrCString#
                                                                                                     @ b
                                                                                                     "index too large: "#
                                                                                                     c
                                                                                                     n4)
                                                                                                  (GHC.Base.augment
                                                                                                     @ GHC.Types.Char
                                                                                                     (\ @ b
                                                                                                        (c :: GHC.Types.Char
                                                                                                              -> b
                                                                                                              -> b)[OneShot]
                                                                                                        (n4 :: b)[OneShot] ->
                                                                                                      GHC.Base.foldr
                                                                                                        @ GHC.Types.Char
                                                                                                        @ b
                                                                                                        c
                                                                                                        n4
                                                                                                        (GHC.Show.showSignedInt
                                                                                                           GHC.Show.$fShow(,)1
                                                                                                           n3
                                                                                                           (GHC.Types.[]
                                                                                                              @ GHC.Types.Char)))
                                                                                                     (GHC.Base.augment
                                                                                                        @ GHC.Types.Char
                                                                                                        (\ @ b
                                                                                                           (c :: GHC.Types.Char
                                                                                                                 -> b
                                                                                                                 -> b)[OneShot]
                                                                                                           (n4 :: b)[OneShot] ->
                                                                                                         GHC.CString.unpackFoldrCString#
                                                                                                           @ b
                                                                                                           ", length = "#
                                                                                                           c
                                                                                                           n4)
                                                                                                        (GHC.Show.showSignedInt
                                                                                                           GHC.Show.$fShow(,)1
                                                                                                           (GHC.Types.I#
                                                                                                              dt3)
                                                                                                           (GHC.Types.[]
                                                                                                              @ GHC.Types.Char)))))
                                                                                        ret_ty Utils.Conduit.ByteLine
                                                                                        of {} }
                                                                                GHC.Types.True
                                                                                -> case Data.ByteString.moduleError
                                                                                          @ GHC.Word.Word8
                                                                                          (GHC.Base.build
                                                                                             @ GHC.Types.Char
                                                                                             (\ @ b ->
                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                @ b
                                                                                                "index"#))
                                                                                          (GHC.Base.augment
                                                                                             @ GHC.Types.Char
                                                                                             (\ @ b
                                                                                                (c :: GHC.Types.Char
                                                                                                      -> b
                                                                                                      -> b)[OneShot]
                                                                                                (n4 :: b)[OneShot] ->
                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                @ b
                                                                                                "negative index: "#
                                                                                                c
                                                                                                n4)
                                                                                             (GHC.Show.showSignedInt
                                                                                                GHC.Show.$fShow(,)1
                                                                                                n3
                                                                                                (GHC.Types.[]
                                                                                                   @ GHC.Types.Char)))
                                                                                   ret_ty Utils.Conduit.ByteLine
                                                                                   of {} }
                                                                           GHC.Types.True
                                                                           -> wild6
                                                                                `cast`
                                                                              (Sym (Utils.Conduit.N:ByteLine[0])) } })
                                                                        s# of s'# { DEFAULT ->
                                                                 (# s'#, GHC.Tuple.() #) })
                                                                  `cast`
                                                                (((GHC.Prim.State#
                                                                     (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                  ->_R ((#,#)
                                                                          <'GHC.Types.TupleRep
                                                                             '[]>_R
                                                                          <'GHC.Types.LiftedRep>_R
                                                                          (GHC.Prim.State#
                                                                             (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                          <()>_R)_R) ; Sym (GHC.Types.N:IO[0]
                                                                                                <()>_R)) } } } })
                                               } in
                                               let {
                                                 k :: Data.Conduit.Internal.Conduit.ConduitT
                                                        Data.ByteString.Internal.ByteString
                                                        (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                        m
                                                        ()
                                                 = finish
                                                     ds1
                                                     (case ds2 of wild2 { GHC.Types.I# x ->
                                                      GHC.Types.I# (GHC.Prim.+# x 1#) })
                                                     (GHC.Types.[]
                                                        @ Data.ByteString.Internal.ByteString)
                                               } in
                                               (\ @ b2
                                                  (h1 :: ()
                                                         -> Data.Conduit.Internal.Pipe.Pipe
                                                              Data.ByteString.Internal.ByteString
                                                              Data.ByteString.Internal.ByteString
                                                              (Data.Vector.Vector
                                                                 Utils.Conduit.ByteLine)
                                                              ()
                                                              m
                                                              b2) ->
                                                (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                                                   @ Data.ByteString.Internal.ByteString
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   @ m
                                                   @ ()
                                                   f1
                                                   m1)
                                                  `cast`
                                                (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                     <Data.ByteString.Internal.ByteString>_N
                                                     <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                                     <m>_N
                                                     <()>_R)
                                                  @ b2
                                                  (\ (a2 :: ()) ->
                                                   k `cast`
                                                   (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                        <Data.ByteString.Internal.ByteString>_N
                                                        <Data.Vector.Vector
                                                           Utils.Conduit.ByteLine>_N
                                                        <m>_N
                                                        <()>_R)
                                                     @ b2
                                                     h1))
                                                 `cast`
                                               (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                         <Data.ByteString.Internal.ByteString>_N
                                                         <Data.Vector.Vector
                                                            Utils.Conduit.ByteLine>_N
                                                         <m>_N
                                                         <()>_R)) }
                                      } in
                                      case ds2 of wild1 { GHC.Types.I# ds4 ->
                                      case ds4 of ds5 {
                                        DEFAULT -> fail GHC.Prim.void#
                                        0#
                                        -> case ds3 of wild2 {
                                             []
                                             -> (\ @ b
                                                   (ds6 :: ()
                                                           -> Data.Conduit.Internal.Pipe.Pipe
                                                                Data.ByteString.Internal.ByteString
                                                                Data.ByteString.Internal.ByteString
                                                                (Data.Vector.Vector
                                                                   Utils.Conduit.ByteLine)
                                                                ()
                                                                m
                                                                b) ->
                                                 ds6 GHC.Tuple.())
                                                  `cast`
                                                (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                          <Data.ByteString.Internal.ByteString>_N
                                                          <Data.Vector.Vector
                                                             Utils.Conduit.ByteLine>_N
                                                          <m>_N
                                                          <()>_R))
                                             : ipv ipv1 -> fail GHC.Prim.void# } } }
                                  } in
                                  finish vec vix toks
                              } in
                              (\ @ b2
                                 (h1 :: ()
                                        -> Data.Conduit.Internal.Pipe.Pipe
                                             Data.ByteString.Internal.ByteString
                                             Data.ByteString.Internal.ByteString
                                             (Data.Vector.Vector Utils.Conduit.ByteLine)
                                             ()
                                             m
                                             b2) ->
                               (Data.Conduit.Internal.Conduit.await
                                  @ m
                                  @ Data.ByteString.Internal.ByteString
                                  $dMonad
                                  @ (Data.Vector.Vector Utils.Conduit.ByteLine))
                                 `cast`
                               (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                    <Data.ByteString.Internal.ByteString>_N
                                    <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                    <m>_N
                                    <GHC.Maybe.Maybe Data.ByteString.Internal.ByteString>_R)
                                 @ b2
                                 (\ (a2 :: GHC.Maybe.Maybe Data.ByteString.Internal.ByteString) ->
                                  case a2 of wild1 {
                                    GHC.Maybe.Nothing
                                    -> n1
                                         `cast`
                                       (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                            <Data.ByteString.Internal.ByteString>_N
                                            <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                            <m>_N
                                            <()>_R)
                                         @ b2
                                         h1
                                    GHC.Maybe.Just x
                                    -> (Data.Conduit.Internal.Conduit.$fMonadIOConduitT_$clift
                                          @ Data.ByteString.Internal.ByteString
                                          @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                          @ m
                                          @ ([Data.Vector.Vector Utils.Conduit.ByteLine],
                                             Data.Vector.Mutable.MVector
                                               GHC.Prim.RealWorld Utils.Conduit.ByteLine,
                                             GHC.Types.Int, GHC.Types.Int,
                                             [Data.ByteString.Internal.ByteString])
                                          (Control.Monad.IO.Class.$p1MonadIO @ m $dMonadIO)
                                          (Control.Monad.IO.Class.liftIO
                                             @ m
                                             $dMonadIO
                                             @ ([Data.Vector.Vector Utils.Conduit.ByteLine],
                                                Data.Vector.Mutable.MVector
                                                  GHC.Prim.RealWorld Utils.Conduit.ByteLine,
                                                GHC.Types.Int, GHC.Types.Int,
                                                [Data.ByteString.Internal.ByteString])
                                             (letrec {
                                                splitWrite :: [Data.Vector.Vector
                                                                 Utils.Conduit.ByteLine]
                                                              -> Data.Vector.Mutable.MVector
                                                                   (Control.Monad.Primitive.PrimState
                                                                      GHC.Types.IO)
                                                                   Utils.Conduit.ByteLine
                                                              -> GHC.Types.Int
                                                              -> GHC.Types.Int
                                                              -> [Data.ByteString.Internal.ByteString]
                                                              -> Data.ByteString.Internal.ByteString
                                                              -> GHC.Types.IO
                                                                   ([Data.Vector.Vector
                                                                       Utils.Conduit.ByteLine],
                                                                    Data.Vector.Mutable.MVector
                                                                      (Control.Monad.Primitive.PrimState
                                                                         GHC.Types.IO)
                                                                      Utils.Conduit.ByteLine,
                                                                    GHC.Types.Int, GHC.Types.Int,
                                                                    [Data.ByteString.Internal.ByteString])
                                                  {- Arity: 6 -}
                                                = \ (done :: [Data.Vector.Vector
                                                                Utils.Conduit.ByteLine])
                                                    (vec1 :: Data.Vector.Mutable.MVector
                                                               (Control.Monad.Primitive.PrimState
                                                                  GHC.Types.IO)
                                                               Utils.Conduit.ByteLine)
                                                    (vix1 :: GHC.Types.Int)
                                                    (n2 :: GHC.Types.Int)
                                                    (toks1 :: [Data.ByteString.Internal.ByteString])
                                                    (tok :: Data.ByteString.Internal.ByteString) ->
                                                  case n2 of n3 { GHC.Types.I# ipv ->
                                                  case GHC.Classes.geInt vix1 nlines of wild2 {
                                                    GHC.Types.False
                                                    -> case tok of wild3 { Data.ByteString.Internal.PS dt dt1 dt2 dt3 ->
                                                       let {
                                                         p' :: GHC.Prim.Addr#
                                                         = GHC.Prim.plusAddr# dt dt2
                                                       } in
                                                       case {__pkg_ccall bytestring-0.10.8.2 GHC.Prim.Addr#
                                                                                             -> GHC.Prim.Int#
                                                                                             -> GHC.Prim.Word#
                                                                                             -> GHC.Prim.State#
                                                                                                  GHC.Prim.RealWorld
                                                                                             -> (# GHC.Prim.State#
                                                                                                     GHC.Prim.RealWorld,
                                                                                                   GHC.Prim.Addr# #)}
                                                              p'
                                                              10#
                                                              (GHC.Prim.int2Word# dt3)
                                                              GHC.Prim.realWorld# of wild4 { (#,#) ds4 ds5 ->
                                                       case GHC.Prim.eqAddr# ds5 __NULL of lwild {
                                                         DEFAULT
                                                         -> case GHC.Prim.touch#
                                                                   @ 'GHC.Types.LiftedRep
                                                                   @ GHC.ForeignPtr.ForeignPtrContents
                                                                   dt1
                                                                   ds4 of s' { DEFAULT ->
                                                            let {
                                                              ix :: GHC.Prim.Int#
                                                              = GHC.Prim.minusAddr# ds5 p'
                                                            } in
                                                            let {
                                                              ix1 :: GHC.Types.Int = GHC.Types.I# ix
                                                            } in
                                                            let {
                                                              ds1 :: (Data.ByteString.Internal.ByteString,
                                                                      Data.ByteString.Internal.ByteString)
                                                              = let {
                                                                  x1 :: GHC.ForeignPtr.ForeignPtr
                                                                          GHC.Word.Word8
                                                                  = GHC.ForeignPtr.ForeignPtr
                                                                      @ GHC.Word.Word8
                                                                      dt
                                                                      dt1
                                                                } in
                                                                case GHC.Classes.leInt
                                                                       ix1
                                                                       (GHC.Types.I# 0#) of wild5 {
                                                                  GHC.Types.False
                                                                  -> case GHC.Classes.geInt
                                                                            ix1
                                                                            (GHC.Types.I#
                                                                               dt3) of wild6 {
                                                                       GHC.Types.False
                                                                       -> (Data.ByteString.Internal.$WPS
                                                                             x1
                                                                             (GHC.Types.I# dt2)
                                                                             ix1,
                                                                           Data.ByteString.Internal.$WPS
                                                                             x1
                                                                             (GHC.Types.I#
                                                                                (GHC.Prim.+#
                                                                                   dt2
                                                                                   ix))
                                                                             (GHC.Types.I#
                                                                                (GHC.Prim.-#
                                                                                   dt3
                                                                                   ix)))
                                                                       GHC.Types.True
                                                                       -> (wild3,
                                                                           Data.ByteString.empty) }
                                                                  GHC.Types.True
                                                                  -> (Data.ByteString.empty,
                                                                      wild3) }
                                                            } in
                                                            (\ (s :: GHC.Prim.State#
                                                                       GHC.Prim.RealWorld) ->
                                                             let {
                                                               file :: GHC.Base.String
                                                               = GHC.Base.build
                                                                   @ GHC.Types.Char
                                                                   (\ @ b ->
                                                                    GHC.CString.unpackFoldrCString#
                                                                      @ b
                                                                      "./Data/Vector/Generic/Mutable.hs"#)
                                                             } in
                                                             case GHC.Classes.geInt
                                                                    vix1
                                                                    (GHC.Types.I# 0#) of wild5 {
                                                               GHC.Types.False
                                                               -> case vix1 of wild6 { GHC.Types.I# i# ->
                                                                  case vec1 of wild7 { Data.Vector.Mutable.MVector dt4 dt5 dt6 ->
                                                                  case Data.Vector.Internal.Check.checkError
                                                                         @ (GHC.Types.IO ())
                                                                         file
                                                                         (GHC.Types.I# 697#)
                                                                         Data.Vector.Internal.Check.Bounds
                                                                         (GHC.Base.build
                                                                            @ GHC.Types.Char
                                                                            (\ @ b ->
                                                                             GHC.CString.unpackFoldrCString#
                                                                               @ b
                                                                               "write"#))
                                                                         (Data.Vector.Internal.Check.checkIndex_msg#
                                                                            i#
                                                                            dt5)
                                                                  ret_ty (# GHC.Prim.State#
                                                                              GHC.Prim.RealWorld,
                                                                            ([Data.Vector.Vector
                                                                                Utils.Conduit.ByteLine],
                                                                             Data.Vector.Mutable.MVector
                                                                               (Control.Monad.Primitive.PrimState
                                                                                  GHC.Types.IO)
                                                                               Utils.Conduit.ByteLine,
                                                                             GHC.Types.Int,
                                                                             GHC.Types.Int,
                                                                             [Data.ByteString.Internal.ByteString]) #)
                                                                  of {} } }
                                                               GHC.Types.True
                                                               -> case vec1 of wild6 { Data.Vector.Mutable.MVector dt4 dt5 dt6 ->
                                                                  case GHC.Classes.ltInt
                                                                         vix1
                                                                         (GHC.Types.I#
                                                                            dt5) of wild7 {
                                                                    GHC.Types.False
                                                                    -> case vix1 of wild8 { GHC.Types.I# i# ->
                                                                       case Data.Vector.Internal.Check.checkError
                                                                              @ (GHC.Types.IO ())
                                                                              file
                                                                              (GHC.Types.I# 697#)
                                                                              Data.Vector.Internal.Check.Bounds
                                                                              (GHC.Base.build
                                                                                 @ GHC.Types.Char
                                                                                 (\ @ b ->
                                                                                  GHC.CString.unpackFoldrCString#
                                                                                    @ b
                                                                                    "write"#))
                                                                              (Data.Vector.Internal.Check.checkIndex_msg#
                                                                                 i#
                                                                                 dt5)
                                                                       ret_ty (# GHC.Prim.State#
                                                                                   GHC.Prim.RealWorld,
                                                                                 ([Data.Vector.Vector
                                                                                     Utils.Conduit.ByteLine],
                                                                                  Data.Vector.Mutable.MVector
                                                                                    (Control.Monad.Primitive.PrimState
                                                                                       GHC.Types.IO)
                                                                                    Utils.Conduit.ByteLine,
                                                                                  GHC.Types.Int,
                                                                                  GHC.Types.Int,
                                                                                  [Data.ByteString.Internal.ByteString]) #)
                                                                       of {} }
                                                                    GHC.Types.True
                                                                    -> case vix1 of wild8 { GHC.Types.I# y ->
                                                                       case GHC.Prim.writeArray#
                                                                              @ (Control.Monad.Primitive.PrimState
                                                                                   GHC.Types.IO)
                                                                              @ Utils.Conduit.ByteLine
                                                                              dt6
                                                                              (GHC.Prim.+# dt4 y)
                                                                              (case toks1 of wild9 {
                                                                                 []
                                                                                 -> case ds1 of wild10 { (,) start rest ->
                                                                                    case start of wild11 { Data.ByteString.Internal.PS dt7 dt8 dt9 dt10 ->
                                                                                    case GHC.Classes.leInt
                                                                                           (GHC.Types.I#
                                                                                              dt10)
                                                                                           (GHC.Types.I#
                                                                                              0#) of wild12 {
                                                                                      GHC.Types.False
                                                                                      -> let {
                                                                                           n4 :: GHC.Prim.Int#
                                                                                           = GHC.Prim.-#
                                                                                               dt10
                                                                                               1#
                                                                                         } in
                                                                                         let {
                                                                                           n5 :: GHC.Types.Int
                                                                                           = GHC.Types.I#
                                                                                               n4
                                                                                         } in
                                                                                         case GHC.Classes.ltInt
                                                                                                n5
                                                                                                (GHC.Types.I#
                                                                                                   0#) of wild13 {
                                                                                           GHC.Types.False
                                                                                           -> case GHC.Classes.geInt
                                                                                                     n5
                                                                                                     (GHC.Types.I#
                                                                                                        dt10) of wild14 {
                                                                                                GHC.Types.False
                                                                                                -> case GHC.Prim.readWord8OffAddr#
                                                                                                          @ GHC.Prim.RealWorld
                                                                                                          (GHC.Prim.plusAddr#
                                                                                                             dt7
                                                                                                             (GHC.Prim.+#
                                                                                                                dt9
                                                                                                                n4))
                                                                                                          0#
                                                                                                          GHC.Prim.realWorld# of ds2 { (#,#) ipv1 ipv2 ->
                                                                                                   case GHC.Prim.touch#
                                                                                                          @ 'GHC.Types.LiftedRep
                                                                                                          @ GHC.ForeignPtr.ForeignPtrContents
                                                                                                          dt8
                                                                                                          ipv1 of s'1 { DEFAULT ->
                                                                                                   case GHC.Word.eqWord8
                                                                                                          (GHC.Word.W8#
                                                                                                             ipv2)
                                                                                                          (GHC.Word.W8#
                                                                                                             13##) of wild15 {
                                                                                                     GHC.Types.False
                                                                                                     -> wild11
                                                                                                          `cast`
                                                                                                        (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                                     GHC.Types.True
                                                                                                     -> let {
                                                                                                          n6 :: GHC.Prim.Int#
                                                                                                          = GHC.Prim.-#
                                                                                                              dt10
                                                                                                              1#
                                                                                                        } in
                                                                                                        let {
                                                                                                          n7 :: GHC.Types.Int
                                                                                                          = GHC.Types.I#
                                                                                                              n6
                                                                                                        } in
                                                                                                        case GHC.Classes.leInt
                                                                                                               n7
                                                                                                               (GHC.Types.I#
                                                                                                                  0#) of wild16 {
                                                                                                          GHC.Types.False
                                                                                                          -> case GHC.Classes.geInt
                                                                                                                    n7
                                                                                                                    (GHC.Types.I#
                                                                                                                       dt10) of wild17 {
                                                                                                               GHC.Types.False
                                                                                                               -> (Data.ByteString.Internal.$WPS
                                                                                                                     (GHC.ForeignPtr.ForeignPtr
                                                                                                                        @ GHC.Word.Word8
                                                                                                                        dt7
                                                                                                                        dt8)
                                                                                                                     (GHC.Types.I#
                                                                                                                        dt9)
                                                                                                                     n7)
                                                                                                                    `cast`
                                                                                                                  (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                                               GHC.Types.True
                                                                                                               -> wild11
                                                                                                                    `cast`
                                                                                                                  (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                                                                          GHC.Types.True
                                                                                                          -> Data.ByteString.empty
                                                                                                               `cast`
                                                                                                             (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                                                                                GHC.Types.True
                                                                                                -> case Data.ByteString.moduleError
                                                                                                          @ GHC.Word.Word8
                                                                                                          (GHC.Base.build
                                                                                                             @ GHC.Types.Char
                                                                                                             (\ @ b ->
                                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                                @ b
                                                                                                                "index"#))
                                                                                                          (GHC.Base.augment
                                                                                                             @ GHC.Types.Char
                                                                                                             (\ @ b
                                                                                                                (c :: GHC.Types.Char
                                                                                                                      -> b
                                                                                                                      -> b)[OneShot]
                                                                                                                (n6 :: b)[OneShot] ->
                                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                                @ b
                                                                                                                "index too large: "#
                                                                                                                c
                                                                                                                n6)
                                                                                                             (GHC.Base.augment
                                                                                                                @ GHC.Types.Char
                                                                                                                (\ @ b
                                                                                                                   (c :: GHC.Types.Char
                                                                                                                         -> b
                                                                                                                         -> b)[OneShot]
                                                                                                                   (n6 :: b)[OneShot] ->
                                                                                                                 GHC.Base.foldr
                                                                                                                   @ GHC.Types.Char
                                                                                                                   @ b
                                                                                                                   c
                                                                                                                   n6
                                                                                                                   (GHC.Show.showSignedInt
                                                                                                                      GHC.Show.$fShow(,)1
                                                                                                                      n5
                                                                                                                      (GHC.Types.[]
                                                                                                                         @ GHC.Types.Char)))
                                                                                                                (GHC.Base.augment
                                                                                                                   @ GHC.Types.Char
                                                                                                                   (\ @ b
                                                                                                                      (c :: GHC.Types.Char
                                                                                                                            -> b
                                                                                                                            -> b)[OneShot]
                                                                                                                      (n6 :: b)[OneShot] ->
                                                                                                                    GHC.CString.unpackFoldrCString#
                                                                                                                      @ b
                                                                                                                      ", length = "#
                                                                                                                      c
                                                                                                                      n6)
                                                                                                                   (GHC.Show.showSignedInt
                                                                                                                      GHC.Show.$fShow(,)1
                                                                                                                      (GHC.Types.I#
                                                                                                                         dt10)
                                                                                                                      (GHC.Types.[]
                                                                                                                         @ GHC.Types.Char)))))
                                                                                                   ret_ty Utils.Conduit.ByteLine
                                                                                                   of {} }
                                                                                           GHC.Types.True
                                                                                           -> case Data.ByteString.moduleError
                                                                                                     @ GHC.Word.Word8
                                                                                                     (GHC.Base.build
                                                                                                        @ GHC.Types.Char
                                                                                                        (\ @ b ->
                                                                                                         GHC.CString.unpackFoldrCString#
                                                                                                           @ b
                                                                                                           "index"#))
                                                                                                     (GHC.Base.augment
                                                                                                        @ GHC.Types.Char
                                                                                                        (\ @ b
                                                                                                           (c :: GHC.Types.Char
                                                                                                                 -> b
                                                                                                                 -> b)[OneShot]
                                                                                                           (n6 :: b)[OneShot] ->
                                                                                                         GHC.CString.unpackFoldrCString#
                                                                                                           @ b
                                                                                                           "negative index: "#
                                                                                                           c
                                                                                                           n6)
                                                                                                        (GHC.Show.showSignedInt
                                                                                                           GHC.Show.$fShow(,)1
                                                                                                           n5
                                                                                                           (GHC.Types.[]
                                                                                                              @ GHC.Types.Char)))
                                                                                              ret_ty Utils.Conduit.ByteLine
                                                                                              of {} }
                                                                                      GHC.Types.True
                                                                                      -> wild11
                                                                                           `cast`
                                                                                         (Sym (Utils.Conduit.N:ByteLine[0])) } } }
                                                                                 : ipv1 ipv2
                                                                                 -> case Data.ByteString.concat
                                                                                           (GHC.List.reverse1
                                                                                              @ Data.ByteString.Internal.ByteString
                                                                                              (GHC.Types.:
                                                                                                 @ Data.ByteString.Internal.ByteString
                                                                                                 (case ds1 of wild10 { (,) start rest ->
                                                                                                  start })
                                                                                                 wild9)
                                                                                              (GHC.Types.[]
                                                                                                 @ Data.ByteString.Internal.ByteString)) of wild10 { Data.ByteString.Internal.PS dt7 dt8 dt9 dt10 ->
                                                                                    case GHC.Classes.leInt
                                                                                           (GHC.Types.I#
                                                                                              dt10)
                                                                                           (GHC.Types.I#
                                                                                              0#) of wild11 {
                                                                                      GHC.Types.False
                                                                                      -> let {
                                                                                           n4 :: GHC.Prim.Int#
                                                                                           = GHC.Prim.-#
                                                                                               dt10
                                                                                               1#
                                                                                         } in
                                                                                         let {
                                                                                           n5 :: GHC.Types.Int
                                                                                           = GHC.Types.I#
                                                                                               n4
                                                                                         } in
                                                                                         case GHC.Classes.ltInt
                                                                                                n5
                                                                                                (GHC.Types.I#
                                                                                                   0#) of wild12 {
                                                                                           GHC.Types.False
                                                                                           -> case GHC.Classes.geInt
                                                                                                     n5
                                                                                                     (GHC.Types.I#
                                                                                                        dt10) of wild13 {
                                                                                                GHC.Types.False
                                                                                                -> case GHC.Prim.readWord8OffAddr#
                                                                                                          @ GHC.Prim.RealWorld
                                                                                                          (GHC.Prim.plusAddr#
                                                                                                             dt7
                                                                                                             (GHC.Prim.+#
                                                                                                                dt9
                                                                                                                n4))
                                                                                                          0#
                                                                                                          GHC.Prim.realWorld# of ds2 { (#,#) ipv3 ipv4 ->
                                                                                                   case GHC.Prim.touch#
                                                                                                          @ 'GHC.Types.LiftedRep
                                                                                                          @ GHC.ForeignPtr.ForeignPtrContents
                                                                                                          dt8
                                                                                                          ipv3 of s'1 { DEFAULT ->
                                                                                                   case GHC.Word.eqWord8
                                                                                                          (GHC.Word.W8#
                                                                                                             ipv4)
                                                                                                          (GHC.Word.W8#
                                                                                                             13##) of wild14 {
                                                                                                     GHC.Types.False
                                                                                                     -> wild10
                                                                                                          `cast`
                                                                                                        (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                                     GHC.Types.True
                                                                                                     -> let {
                                                                                                          n6 :: GHC.Prim.Int#
                                                                                                          = GHC.Prim.-#
                                                                                                              dt10
                                                                                                              1#
                                                                                                        } in
                                                                                                        let {
                                                                                                          n7 :: GHC.Types.Int
                                                                                                          = GHC.Types.I#
                                                                                                              n6
                                                                                                        } in
                                                                                                        case GHC.Classes.leInt
                                                                                                               n7
                                                                                                               (GHC.Types.I#
                                                                                                                  0#) of wild15 {
                                                                                                          GHC.Types.False
                                                                                                          -> case GHC.Classes.geInt
                                                                                                                    n7
                                                                                                                    (GHC.Types.I#
                                                                                                                       dt10) of wild16 {
                                                                                                               GHC.Types.False
                                                                                                               -> (Data.ByteString.Internal.$WPS
                                                                                                                     (GHC.ForeignPtr.ForeignPtr
                                                                                                                        @ GHC.Word.Word8
                                                                                                                        dt7
                                                                                                                        dt8)
                                                                                                                     (GHC.Types.I#
                                                                                                                        dt9)
                                                                                                                     n7)
                                                                                                                    `cast`
                                                                                                                  (Sym (Utils.Conduit.N:ByteLine[0]))
                                                                                                               GHC.Types.True
                                                                                                               -> wild10
                                                                                                                    `cast`
                                                                                                                  (Sym (Utils.Conduit.N:ByteLine[0])) }
                                                                                                          GHC.Types.True
                                                                                                          -> Data.ByteString.empty
                                                                                                               `cast`
                                                                                                             (Sym (Utils.Conduit.N:ByteLine[0])) } } } }
                                                                                                GHC.Types.True
                                                                                                -> case Data.ByteString.moduleError
                                                                                                          @ GHC.Word.Word8
                                                                                                          (GHC.Base.build
                                                                                                             @ GHC.Types.Char
                                                                                                             (\ @ b ->
                                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                                @ b
                                                                                                                "index"#))
                                                                                                          (GHC.Base.augment
                                                                                                             @ GHC.Types.Char
                                                                                                             (\ @ b
                                                                                                                (c :: GHC.Types.Char
                                                                                                                      -> b
                                                                                                                      -> b)[OneShot]
                                                                                                                (n6 :: b)[OneShot] ->
                                                                                                              GHC.CString.unpackFoldrCString#
                                                                                                                @ b
                                                                                                                "index too large: "#
                                                                                                                c
                                                                                                                n6)
                                                                                                             (GHC.Base.augment
                                                                                                                @ GHC.Types.Char
                                                                                                                (\ @ b
                                                                                                                   (c :: GHC.Types.Char
                                                                                                                         -> b
                                                                                                                         -> b)[OneShot]
                                                                                                                   (n6 :: b)[OneShot] ->
                                                                                                                 GHC.Base.foldr
                                                                                                                   @ GHC.Types.Char
                                                                                                                   @ b
                                                                                                                   c
                                                                                                                   n6
                                                                                                                   (GHC.Show.showSignedInt
                                                                                                                      GHC.Show.$fShow(,)1
                                                                                                                      n5
                                                                                                                      (GHC.Types.[]
                                                                                                                         @ GHC.Types.Char)))
                                                                                                                (GHC.Base.augment
                                                                                                                   @ GHC.Types.Char
                                                                                                                   (\ @ b
                                                                                                                      (c :: GHC.Types.Char
                                                                                                                            -> b
                                                                                                                            -> b)[OneShot]
                                                                                                                      (n6 :: b)[OneShot] ->
                                                                                                                    GHC.CString.unpackFoldrCString#
                                                                                                                      @ b
                                                                                                                      ", length = "#
                                                                                                                      c
                                                                                                                      n6)
                                                                                                                   (GHC.Show.showSignedInt
                                                                                                                      GHC.Show.$fShow(,)1
                                                                                                                      (GHC.Types.I#
                                                                                                                         dt10)
                                                                                                                      (GHC.Types.[]
                                                                                                                         @ GHC.Types.Char)))))
                                                                                                   ret_ty Utils.Conduit.ByteLine
                                                                                                   of {} }
                                                                                           GHC.Types.True
                                                                                           -> case Data.ByteString.moduleError
                                                                                                     @ GHC.Word.Word8
                                                                                                     (GHC.Base.build
                                                                                                        @ GHC.Types.Char
                                                                                                        (\ @ b ->
                                                                                                         GHC.CString.unpackFoldrCString#
                                                                                                           @ b
                                                                                                           "index"#))
                                                                                                     (GHC.Base.augment
                                                                                                        @ GHC.Types.Char
                                                                                                        (\ @ b
                                                                                                           (c :: GHC.Types.Char
                                                                                                                 -> b
                                                                                                                 -> b)[OneShot]
                                                                                                           (n6 :: b)[OneShot] ->
                                                                                                         GHC.CString.unpackFoldrCString#
                                                                                                           @ b
                                                                                                           "negative index: "#
                                                                                                           c
                                                                                                           n6)
                                                                                                        (GHC.Show.showSignedInt
                                                                                                           GHC.Show.$fShow(,)1
                                                                                                           n5
                                                                                                           (GHC.Types.[]
                                                                                                              @ GHC.Types.Char)))
                                                                                              ret_ty Utils.Conduit.ByteLine
                                                                                              of {} }
                                                                                      GHC.Types.True
                                                                                      -> wild10
                                                                                           `cast`
                                                                                         (Sym (Utils.Conduit.N:ByteLine[0])) } } })
                                                                              s `cast`
                                                                              (Nth:2
                                                                                   ((GHC.Prim.State#
                                                                                       (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                                    ->_R ((#,#)
                                                                                            <'GHC.Types.TupleRep
                                                                                               '[]>_R
                                                                                            <'GHC.Types.LiftedRep>_R
                                                                                            (GHC.Prim.State#
                                                                                               (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                                            <()>_R)_R)) of s'# { DEFAULT ->
                                                                       (splitWrite
                                                                          done
                                                                          wild6
                                                                          (GHC.Types.I#
                                                                             (GHC.Prim.+# y 1#))
                                                                          (GHC.Types.I# 0#)
                                                                          (GHC.Types.[]
                                                                             @ Data.ByteString.Internal.ByteString)
                                                                          (case ds1 of wild9 { (,) start rest ->
                                                                           case rest of wild10 { Data.ByteString.Internal.PS dt7 dt8 dt9 dt10 ->
                                                                           case GHC.Classes.leInt
                                                                                  (GHC.Types.I#
                                                                                     dt10)
                                                                                  (GHC.Types.I#
                                                                                     0#) of wild11 {
                                                                             GHC.Types.False
                                                                             -> Data.ByteString.Internal.$WPS
                                                                                  (GHC.ForeignPtr.ForeignPtr
                                                                                     @ GHC.Word.Word8
                                                                                     dt7
                                                                                     dt8)
                                                                                  (GHC.Types.I#
                                                                                     (GHC.Prim.+#
                                                                                        dt9
                                                                                        1#))
                                                                                  (GHC.Types.I#
                                                                                     (GHC.Prim.-#
                                                                                        dt10
                                                                                        1#))
                                                                             GHC.Types.True
                                                                             -> Data.ByteString.errorEmptyList
                                                                                  @ Data.ByteString.Internal.ByteString
                                                                                  (GHC.Base.build
                                                                                     @ GHC.Types.Char
                                                                                     (\ @ b ->
                                                                                      GHC.CString.unpackFoldrCString#
                                                                                        @ b
                                                                                        "tail"#)) } } }))
                                                                         `cast`
                                                                       (GHC.Types.N:IO[0]
                                                                            <([Data.Vector.Vector
                                                                                 Utils.Conduit.ByteLine],
                                                                              Data.Vector.Mutable.MVector
                                                                                (Control.Monad.Primitive.PrimState
                                                                                   GHC.Types.IO)
                                                                                Utils.Conduit.ByteLine,
                                                                              GHC.Types.Int,
                                                                              GHC.Types.Int,
                                                                              [Data.ByteString.Internal.ByteString])>_R)
                                                                         s'#
                                                                           `cast`
                                                                         (Nth:2
                                                                              (Nth:3
                                                                                   ((GHC.Prim.State#
                                                                                       (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                                    ->_R ((#,#)
                                                                                            <'GHC.Types.TupleRep
                                                                                               '[]>_R
                                                                                            <'GHC.Types.LiftedRep>_R
                                                                                            (GHC.Prim.State#
                                                                                               (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                                            <()>_R)_R))) } } } } })
                                                              `cast`
                                                            (Sym (GHC.Types.N:IO[0]
                                                                      <([Data.Vector.Vector
                                                                           Utils.Conduit.ByteLine],
                                                                        Data.Vector.Mutable.MVector
                                                                          (Control.Monad.Primitive.PrimState
                                                                             GHC.Types.IO)
                                                                          Utils.Conduit.ByteLine,
                                                                        GHC.Types.Int,
                                                                        GHC.Types.Int,
                                                                        [Data.ByteString.Internal.ByteString])>_R)) }
                                                         1#
                                                         -> case GHC.Prim.touch#
                                                                   @ 'GHC.Types.LiftedRep
                                                                   @ GHC.ForeignPtr.ForeignPtrContents
                                                                   dt1
                                                                   ds4 of s' { DEFAULT ->
                                                            (\ (s :: GHC.Prim.State#
                                                                       GHC.Prim.RealWorld) ->
                                                             (# s,
                                                                (done, vec1, vix1,
                                                                 GHC.Types.I# (GHC.Prim.+# ipv dt3),
                                                                 case GHC.Classes.leInt
                                                                        (GHC.Types.I# dt3)
                                                                        (GHC.Types.I# 0#) of wild5 {
                                                                   GHC.Types.False
                                                                   -> GHC.Types.:
                                                                        @ Data.ByteString.Internal.ByteString
                                                                        wild3
                                                                        toks1
                                                                   GHC.Types.True -> toks1 }) #))
                                                              `cast`
                                                            (Sym (GHC.Types.N:IO[0]
                                                                      <([Data.Vector.Vector
                                                                           Utils.Conduit.ByteLine],
                                                                        Data.Vector.Mutable.MVector
                                                                          (Control.Monad.Primitive.PrimState
                                                                             GHC.Types.IO)
                                                                          Utils.Conduit.ByteLine,
                                                                        GHC.Types.Int,
                                                                        GHC.Types.Int,
                                                                        [Data.ByteString.Internal.ByteString])>_R)) } } } }
                                                    GHC.Types.True
                                                    -> (\ (s :: GHC.Prim.State#
                                                                  GHC.Prim.RealWorld) ->
                                                        case vec1 of wild3 { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                                        case GHC.Prim.unsafeFreezeArray#
                                                               @ (Control.Monad.Primitive.PrimState
                                                                    GHC.Types.IO)
                                                               @ Utils.Conduit.ByteLine
                                                               dt2
                                                               s `cast`
                                                               (Nth:2
                                                                    ((GHC.Prim.State#
                                                                        (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                     ->_R ((#,#)
                                                                             <'GHC.Types.TupleRep
                                                                                '[]>_R
                                                                             <'GHC.Types.LiftedRep>_R
                                                                             (GHC.Prim.State#
                                                                                (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0])))_R
                                                                             <Data.Primitive.Array.Array
                                                                                Utils.Conduit.ByteLine>_R)_R)) of ds1 { (#,#) ipv1 ipv2 ->
                                                        case GHC.Classes.geInt
                                                               nlines
                                                               (GHC.Types.I# 0#) of wild4 {
                                                          GHC.Types.False
                                                          -> case nlines of wild5 { GHC.Types.I# n# ->
                                                             case Data.Vector.Internal.Check.checkError
                                                                    @ (GHC.Types.IO
                                                                         (Data.Vector.Mutable.MVector
                                                                            (Control.Monad.Primitive.PrimState
                                                                               GHC.Types.IO)
                                                                            Utils.Conduit.ByteLine))
                                                                    (GHC.Base.build
                                                                       @ GHC.Types.Char
                                                                       (\ @ b ->
                                                                        GHC.CString.unpackFoldrCString#
                                                                          @ b
                                                                          "./Data/Vector/Generic/Mutable.hs"#))
                                                                    (GHC.Types.I# 585#)
                                                                    Data.Vector.Internal.Check.Bounds
                                                                    (GHC.Base.build
                                                                       @ GHC.Types.Char
                                                                       (\ @ b ->
                                                                        GHC.CString.unpackFoldrCString#
                                                                          @ b
                                                                          "new"#))
                                                                    (Data.Vector.Internal.Check.checkLength_msg#
                                                                       n#)
                                                             ret_ty (# GHC.Prim.State#
                                                                         GHC.Prim.RealWorld,
                                                                       ([Data.Vector.Vector
                                                                           Utils.Conduit.ByteLine],
                                                                        Data.Vector.Mutable.MVector
                                                                          (Control.Monad.Primitive.PrimState
                                                                             GHC.Types.IO)
                                                                          Utils.Conduit.ByteLine,
                                                                        GHC.Types.Int,
                                                                        GHC.Types.Int,
                                                                        [Data.ByteString.Internal.ByteString]) #)
                                                             of {} }
                                                          GHC.Types.True
                                                          -> case nlines of wild5 { GHC.Types.I# n# ->
                                                             case GHC.Prim.newArray#
                                                                    @ Utils.Conduit.ByteLine
                                                                    @ (Control.Monad.Primitive.PrimState
                                                                         GHC.Types.IO)
                                                                    n#
                                                                    (Data.Vector.Mutable.uninitialised
                                                                       @ Utils.Conduit.ByteLine)
                                                                    ipv1 of ds2 { (#,#) ipv3 ipv4 ->
                                                             (splitWrite
                                                                (GHC.Types.:
                                                                   @ (Data.Vector.Vector
                                                                        Utils.Conduit.ByteLine)
                                                                   (Data.Vector.$WVector
                                                                      @ Utils.Conduit.ByteLine
                                                                      (GHC.Types.I# dt)
                                                                      (GHC.Types.I# dt1)
                                                                      (Data.Primitive.Array.Array
                                                                         @ Utils.Conduit.ByteLine
                                                                         ipv2))
                                                                   done)
                                                                (Data.Vector.Mutable.$WMVector
                                                                   @ (Control.Monad.Primitive.PrimState
                                                                        GHC.Types.IO)
                                                                   @ Utils.Conduit.ByteLine
                                                                   (GHC.Types.I# 0#)
                                                                   wild5
                                                                   (Data.Primitive.Array.MutableArray
                                                                      @ (Control.Monad.Primitive.PrimState
                                                                           GHC.Types.IO)
                                                                      @ Utils.Conduit.ByteLine
                                                                      ipv4))
                                                                (GHC.Types.I# 0#)
                                                                n3
                                                                toks1
                                                                tok)
                                                               `cast`
                                                             (GHC.Types.N:IO[0]
                                                                  <([Data.Vector.Vector
                                                                       Utils.Conduit.ByteLine],
                                                                    Data.Vector.Mutable.MVector
                                                                      (Control.Monad.Primitive.PrimState
                                                                         GHC.Types.IO)
                                                                      Utils.Conduit.ByteLine,
                                                                    GHC.Types.Int, GHC.Types.Int,
                                                                    [Data.ByteString.Internal.ByteString])>_R)
                                                               ipv3
                                                                 `cast`
                                                               (Nth:2
                                                                    (Nth:3
                                                                         ((GHC.Prim.State#
                                                                             (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                          ->_R ((#,#)
                                                                                  <'GHC.Types.TupleRep
                                                                                     '[]>_R
                                                                                  <'GHC.Types.LiftedRep>_R
                                                                                  (GHC.Prim.State#
                                                                                     (Control.Monad.Primitive.D:R:PrimStateIO[0]))_R
                                                                                  <Data.Primitive.Array.MutableArray
                                                                                     (Control.Monad.Primitive.PrimState
                                                                                        GHC.Types.IO)
                                                                                     Utils.Conduit.ByteLine>_R)_R))) } } } } })
                                                         `cast`
                                                       (Sym (GHC.Types.N:IO[0]
                                                                 <([Data.Vector.Vector
                                                                      Utils.Conduit.ByteLine],
                                                                   Data.Vector.Mutable.MVector
                                                                     (Control.Monad.Primitive.PrimState
                                                                        GHC.Types.IO)
                                                                     Utils.Conduit.ByteLine,
                                                                   GHC.Types.Int, GHC.Types.Int,
                                                                   [Data.ByteString.Internal.ByteString])>_R)) } }
                                              } in
                                              (splitWrite
                                                 (GHC.Types.[]
                                                    @ (Data.Vector.Vector Utils.Conduit.ByteLine))
                                                 vec
                                                   `cast`
                                                 (Data.Vector.Mutable.MVector
                                                    (Sym (Control.Monad.Primitive.D:R:PrimStateIO[0]))
                                                    <Utils.Conduit.ByteLine>_R)_R
                                                 vix
                                                 n
                                                 toks
                                                 x)
                                                `cast`
                                              (GHC.Types.IO
                                                 ((,,,,)
                                                    <[Data.Vector.Vector Utils.Conduit.ByteLine]>_R
                                                    (Data.Vector.Mutable.MVector
                                                       (Control.Monad.Primitive.D:R:PrimStateIO[0])
                                                       <Utils.Conduit.ByteLine>_R)_R
                                                    <GHC.Types.Int>_R
                                                    <GHC.Types.Int>_R
                                                    <[Data.ByteString.Internal.ByteString]>_R)_R)_R)))
                                         `cast`
                                       (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                            <Data.ByteString.Internal.ByteString>_N
                                            <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                            <m>_N
                                            <([Data.Vector.Vector Utils.Conduit.ByteLine],
                                              Data.Vector.Mutable.MVector
                                                GHC.Prim.RealWorld Utils.Conduit.ByteLine,
                                              GHC.Types.Int, GHC.Types.Int,
                                              [Data.ByteString.Internal.ByteString])>_R)
                                         @ b2
                                         (\ (a3 :: ([Data.Vector.Vector Utils.Conduit.ByteLine],
                                                    Data.Vector.Mutable.MVector
                                                      GHC.Prim.RealWorld Utils.Conduit.ByteLine,
                                                    GHC.Types.Int, GHC.Types.Int,
                                                    [Data.ByteString.Internal.ByteString])) ->
                                          case a3 of wild2 { (,,,,) done vec' vix' n' toks' ->
                                          let {
                                            k :: Data.Conduit.Internal.Conduit.ConduitT
                                                   Data.ByteString.Internal.ByteString
                                                   (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   m
                                                   ()
                                            = continue vec' vix' n' toks'
                                          } in
                                          let {
                                            xs :: [Data.Vector.Vector Utils.Conduit.ByteLine]
                                            = GHC.List.reverse1
                                                @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                done
                                                (GHC.Types.[]
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine))
                                          } in
                                          (Data.Conduit.Internal.Fusion.unstream
                                             @ Data.ByteString.Internal.ByteString
                                             @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                             @ m
                                             @ ()
                                             (Data.Conduit.Internal.Fusion.ConduitWithStream
                                                @ Data.ByteString.Internal.ByteString
                                                @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                @ m
                                                @ ()
                                                (Data.Foldable.mapM_
                                                   @ []
                                                   @ (Data.Conduit.Internal.Conduit.ConduitT
                                                        Data.ByteString.Internal.ByteString
                                                        (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                        m)
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   @ ()
                                                   Data.Foldable.$fFoldable[]
                                                   (Data.Conduit.Internal.Conduit.$fMonadConduitT
                                                      @ Data.ByteString.Internal.ByteString
                                                      @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                      @ m)
                                                   (Data.Conduit.Internal.Conduit.yield
                                                      @ m
                                                      @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                      @ Data.ByteString.Internal.ByteString
                                                      $dMonad)
                                                   xs)
                                                (Data.Conduit.Internal.List.Stream.sourceListS
                                                   @ m
                                                   @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                                   $dMonad
                                                   xs
                                                   @ Data.ByteString.Internal.ByteString)))
                                            `cast`
                                          (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                               <Data.ByteString.Internal.ByteString>_N
                                               <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                               <m>_N
                                               <()>_R)
                                            @ b2
                                            (\ (a4 :: ()) ->
                                             k `cast`
                                             (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                                  <Data.ByteString.Internal.ByteString>_N
                                                  <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                                  <m>_N
                                                  <()>_R)
                                               @ b2
                                               h1) }) }))
                                `cast`
                              (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                                        <Data.ByteString.Internal.ByteString>_N
                                        <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                                        <m>_N
                                        <()>_R))
                           GHC.Types.True
                           -> Data.Conduit.Internal.Conduit.$fMonadErroreConduitT_$cthrowError
                                @ NGLess.NGError.NGError
                                @ m
                                @ Data.ByteString.Internal.ByteString
                                @ (Data.Vector.Vector Utils.Conduit.ByteLine)
                                $dMonadError
                                @ ()
                                (case GHC.Base.build
                                        @ GHC.Types.Char
                                        (\ @ b
                                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                                           (n1 :: b)[OneShot] ->
                                         GHC.CString.unpackFoldrCString#
                                           @ b
                                           "Line too long (length is "#
                                           c
                                           (GHC.Base.foldr
                                              @ GHC.Types.Char
                                              @ b
                                              c
                                              (GHC.CString.unpackFoldrCString#
                                                 @ b
                                                 " characters)."#
                                                 c
                                                 n1)
                                              (GHC.Show.showSignedInt
                                                 GHC.Show.$fShow(,)1
                                                 n
                                                 (GHC.Types.[]
                                                    @ GHC.Types.Char)))) of dt { DEFAULT ->
                                 NGLess.NGError.NGError NGLess.NGError.DataError dt }) }
                     } in
                     (continue
                        a1
                        (GHC.Types.I# 0#)
                        (GHC.Types.I# 0#)
                        (GHC.Types.[] @ Data.ByteString.Internal.ByteString))
                       `cast`
                     (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                          <Data.ByteString.Internal.ByteString>_N
                          <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                          <m>_N
                          <()>_R)
                       @ b1
                       h))
                   `cast`
                 (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                           <Data.ByteString.Internal.ByteString>_N
                           <Data.Vector.Vector Utils.Conduit.ByteLine>_N
                           <m>_N
                           <()>_R))) -}
f93e0bf42ad74bf0a749a5d582df6f95
  maxLineSize :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.I# 1073741824#) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  unwrapByteLine ::
    Utils.Conduit.ByteLine -> Data.ByteString.Internal.ByteString
  RecSel Left Utils.Conduit.ByteLine
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Utils.Conduit.unwrapByteLine1
                  `cast`
                (<Utils.Conduit.ByteLine>_R ->_R Utils.Conduit.N:ByteLine[0]) -}
981aa5298d35f0c0dbe1b9a7c5c38f9d
  unwrapByteLine1 :: Utils.Conduit.ByteLine -> Utils.Conduit.ByteLine
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Utils.Conduit.ByteLine) -> ds) -}
7f397b4901b51927bb0c46a13df6df26
  zipSink2 ::
    GHC.Base.Monad m =>
    Data.Conduit.Internal.Conduit.ConduitT i Data.Void.Void m a
    -> Data.Conduit.Internal.Conduit.ConduitT i Data.Void.Void m b
    -> Data.Conduit.Internal.Conduit.ConduitT i Data.Void.Void m (a, b)
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,C(U),A)><C(S),1*C1(U)><C(S),1*C1(U)><L,C(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ i
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (a1 :: Data.Conduit.Internal.Conduit.ConduitT i Data.Void.Void m a)
                   (b1 :: Data.Conduit.Internal.Conduit.ConduitT
                            i Data.Void.Void m b) ->
                 let {
                   ds :: forall b2.
                         ((b -> (a, b))
                          -> Data.Conduit.Internal.Pipe.Pipe i i Data.Void.Void () m b2)
                         -> Data.Conduit.Internal.Pipe.Pipe i i Data.Void.Void () m b2
                     {- Arity: 1 -}
                   = \ @ b2
                       (h :: (b -> (a, b))
                             -> Data.Conduit.Internal.Pipe.Pipe i i Data.Void.Void () m b2) ->
                     a1
                       `cast`
                     (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                          <i>_N <Data.Void.Void>_N <m>_N <a>_R)
                       @ b2
                       (\ (a2 :: a) -> h (GHC.Tuple.(,) @ a @ b a2))
                 } in
                 (\ @ b2
                    (eta :: (a, b)
                            -> Data.Conduit.Internal.Pipe.Pipe i i Data.Void.Void () m b2) ->
                  Data.Conduit.Internal.Conduit.$fApplicativeZipSink2
                    @ m
                    @ i
                    @ (b -> (a, b))
                    @ b
                    $dMonad
                    ds
                      `cast`
                    (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                              <i>_N <Data.Void.Void>_N <m>_N <b -> (a, b)>_R))
                    b1
                    @ b2
                    (\ (a2 :: (b -> (a, b), b)) ->
                     eta (case a2 of wild { (,) x ds2 -> x ds2 })))
                   `cast`
                 (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                           <i>_N <Data.Void.Void>_N <m>_N <(a, b)>_R))) -}
a84e4cc79e323606f59b4cf7fca05d5b
  zipSource2 ::
    GHC.Base.Monad m =>
    Data.Conduit.Internal.Conduit.ConduitT () a m ()
    -> Data.Conduit.Internal.Conduit.ConduitT () b m ()
    -> Data.Conduit.Internal.Conduit.ConduitT () (a, b) m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,C(U),A)><C(S),1*C1(U)><C(S),1*C1(U)><L,1*C1(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ m :: * -> *
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (a1 :: Data.Conduit.Internal.Conduit.ConduitT () a m ())
                   (b1 :: Data.Conduit.Internal.Conduit.ConduitT () b m ()) ->
                 Data.Conduit.Internal.Conduit.$fApplicativeZipSource3
                   @ m
                   @ b
                   @ (a, b)
                   $dMonad
                   (\ @ b2
                      (eta1 :: ()
                               -> Data.Conduit.Internal.Pipe.Pipe () () (b -> (a, b)) () m b2) ->
                    Data.Conduit.Internal.Conduit.$fApplicativeZipSource2
                      @ m
                      @ a
                      @ (b -> (a, b))
                      @ ()
                      @ ()
                      $dMonad
                      (GHC.Tuple.(,) @ a @ b)
                      a1
                      @ b2
                      eta1)
                     `cast`
                   (Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                             <()>_N <b -> (a, b)>_N <m>_N <()>_R))
                   b1)
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N) (b :: <*>_N).
                 <GHC.Base.Monad m>_R
                 ->_R <Data.Conduit.Internal.Conduit.ConduitT () a m ()>_R
                 ->_R <Data.Conduit.Internal.Conduit.ConduitT () b m ()>_R
                 ->_R Sym (Data.Conduit.Internal.Conduit.N:ConduitT[0]
                               <()>_N <(a, b)>_N <m>_N <()>_R)) -}
instance GHC.Show.Show [Utils.Conduit.ByteLine]
  = Utils.Conduit.$fShowByteLine
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

